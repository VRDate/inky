// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               v5.28.3
// source: ink/mcp/mcp.proto

/* eslint-disable */

export const protobufPackage = "ink.mcp.model";

export interface JsonRpcRequest {
  jsonrpc: string;
  id: string;
  method: string;
  /** JSON string (flexible params) */
  paramsJson: string;
}

export interface JsonRpcResponse {
  jsonrpc: string;
  id: string;
  /** JSON string (flexible result) */
  resultJson: string;
  error: JsonRpcError | undefined;
}

export interface JsonRpcError {
  code: number;
  message: string;
  dataJson: string;
}

export interface McpServerInfo {
  name: string;
  version: string;
}

export interface McpCapabilities {
  tools: McpToolCapability | undefined;
}

export interface McpToolCapability {
  listChanged: boolean;
}

export interface McpInitializeResult {
  protocolVersion: string;
  capabilities: McpCapabilities | undefined;
  serverInfo: McpServerInfo | undefined;
}

export interface McpToolInfo {
  name: string;
  description: string;
  /** JSON Schema string */
  inputSchemaJson: string;
}

export interface McpToolsListResult {
  tools: McpToolInfo[];
}

export interface McpContentBlock {
  type: string;
  text: string;
}

export interface McpToolResult {
  content: McpContentBlock[];
  isError: boolean;
}

function createBaseJsonRpcRequest(): JsonRpcRequest {
  return { jsonrpc: "", id: "", method: "", paramsJson: "" };
}

export const JsonRpcRequest: MessageFns<JsonRpcRequest> = {
  fromJSON(object: any): JsonRpcRequest {
    return {
      jsonrpc: isSet(object.jsonrpc) ? globalThis.String(object.jsonrpc) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      paramsJson: isSet(object.paramsJson)
        ? globalThis.String(object.paramsJson)
        : isSet(object.params_json)
        ? globalThis.String(object.params_json)
        : "",
    };
  },

  toJSON(message: JsonRpcRequest): unknown {
    const obj: any = {};
    if (message.jsonrpc !== "") {
      obj.jsonrpc = message.jsonrpc;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.paramsJson !== "") {
      obj.paramsJson = message.paramsJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonRpcRequest>, I>>(base?: I): JsonRpcRequest {
    return JsonRpcRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonRpcRequest>, I>>(object: I): JsonRpcRequest {
    const message = createBaseJsonRpcRequest();
    message.jsonrpc = object.jsonrpc ?? "";
    message.id = object.id ?? "";
    message.method = object.method ?? "";
    message.paramsJson = object.paramsJson ?? "";
    return message;
  },
};

function createBaseJsonRpcResponse(): JsonRpcResponse {
  return { jsonrpc: "", id: "", resultJson: "", error: undefined };
}

export const JsonRpcResponse: MessageFns<JsonRpcResponse> = {
  fromJSON(object: any): JsonRpcResponse {
    return {
      jsonrpc: isSet(object.jsonrpc) ? globalThis.String(object.jsonrpc) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      resultJson: isSet(object.resultJson)
        ? globalThis.String(object.resultJson)
        : isSet(object.result_json)
        ? globalThis.String(object.result_json)
        : "",
      error: isSet(object.error) ? JsonRpcError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: JsonRpcResponse): unknown {
    const obj: any = {};
    if (message.jsonrpc !== "") {
      obj.jsonrpc = message.jsonrpc;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.resultJson !== "") {
      obj.resultJson = message.resultJson;
    }
    if (message.error !== undefined) {
      obj.error = JsonRpcError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonRpcResponse>, I>>(base?: I): JsonRpcResponse {
    return JsonRpcResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonRpcResponse>, I>>(object: I): JsonRpcResponse {
    const message = createBaseJsonRpcResponse();
    message.jsonrpc = object.jsonrpc ?? "";
    message.id = object.id ?? "";
    message.resultJson = object.resultJson ?? "";
    message.error = (object.error !== undefined && object.error !== null)
      ? JsonRpcError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseJsonRpcError(): JsonRpcError {
  return { code: 0, message: "", dataJson: "" };
}

export const JsonRpcError: MessageFns<JsonRpcError> = {
  fromJSON(object: any): JsonRpcError {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      dataJson: isSet(object.dataJson)
        ? globalThis.String(object.dataJson)
        : isSet(object.data_json)
        ? globalThis.String(object.data_json)
        : "",
    };
  },

  toJSON(message: JsonRpcError): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.dataJson !== "") {
      obj.dataJson = message.dataJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonRpcError>, I>>(base?: I): JsonRpcError {
    return JsonRpcError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonRpcError>, I>>(object: I): JsonRpcError {
    const message = createBaseJsonRpcError();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.dataJson = object.dataJson ?? "";
    return message;
  },
};

function createBaseMcpServerInfo(): McpServerInfo {
  return { name: "", version: "" };
}

export const McpServerInfo: MessageFns<McpServerInfo> = {
  fromJSON(object: any): McpServerInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: McpServerInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpServerInfo>, I>>(base?: I): McpServerInfo {
    return McpServerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpServerInfo>, I>>(object: I): McpServerInfo {
    const message = createBaseMcpServerInfo();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseMcpCapabilities(): McpCapabilities {
  return { tools: undefined };
}

export const McpCapabilities: MessageFns<McpCapabilities> = {
  fromJSON(object: any): McpCapabilities {
    return { tools: isSet(object.tools) ? McpToolCapability.fromJSON(object.tools) : undefined };
  },

  toJSON(message: McpCapabilities): unknown {
    const obj: any = {};
    if (message.tools !== undefined) {
      obj.tools = McpToolCapability.toJSON(message.tools);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpCapabilities>, I>>(base?: I): McpCapabilities {
    return McpCapabilities.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpCapabilities>, I>>(object: I): McpCapabilities {
    const message = createBaseMcpCapabilities();
    message.tools = (object.tools !== undefined && object.tools !== null)
      ? McpToolCapability.fromPartial(object.tools)
      : undefined;
    return message;
  },
};

function createBaseMcpToolCapability(): McpToolCapability {
  return { listChanged: false };
}

export const McpToolCapability: MessageFns<McpToolCapability> = {
  fromJSON(object: any): McpToolCapability {
    return {
      listChanged: isSet(object.listChanged)
        ? globalThis.Boolean(object.listChanged)
        : isSet(object.list_changed)
        ? globalThis.Boolean(object.list_changed)
        : false,
    };
  },

  toJSON(message: McpToolCapability): unknown {
    const obj: any = {};
    if (message.listChanged !== false) {
      obj.listChanged = message.listChanged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpToolCapability>, I>>(base?: I): McpToolCapability {
    return McpToolCapability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpToolCapability>, I>>(object: I): McpToolCapability {
    const message = createBaseMcpToolCapability();
    message.listChanged = object.listChanged ?? false;
    return message;
  },
};

function createBaseMcpInitializeResult(): McpInitializeResult {
  return { protocolVersion: "", capabilities: undefined, serverInfo: undefined };
}

export const McpInitializeResult: MessageFns<McpInitializeResult> = {
  fromJSON(object: any): McpInitializeResult {
    return {
      protocolVersion: isSet(object.protocolVersion)
        ? globalThis.String(object.protocolVersion)
        : isSet(object.protocol_version)
        ? globalThis.String(object.protocol_version)
        : "",
      capabilities: isSet(object.capabilities) ? McpCapabilities.fromJSON(object.capabilities) : undefined,
      serverInfo: isSet(object.serverInfo)
        ? McpServerInfo.fromJSON(object.serverInfo)
        : isSet(object.server_info)
        ? McpServerInfo.fromJSON(object.server_info)
        : undefined,
    };
  },

  toJSON(message: McpInitializeResult): unknown {
    const obj: any = {};
    if (message.protocolVersion !== "") {
      obj.protocolVersion = message.protocolVersion;
    }
    if (message.capabilities !== undefined) {
      obj.capabilities = McpCapabilities.toJSON(message.capabilities);
    }
    if (message.serverInfo !== undefined) {
      obj.serverInfo = McpServerInfo.toJSON(message.serverInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpInitializeResult>, I>>(base?: I): McpInitializeResult {
    return McpInitializeResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpInitializeResult>, I>>(object: I): McpInitializeResult {
    const message = createBaseMcpInitializeResult();
    message.protocolVersion = object.protocolVersion ?? "";
    message.capabilities = (object.capabilities !== undefined && object.capabilities !== null)
      ? McpCapabilities.fromPartial(object.capabilities)
      : undefined;
    message.serverInfo = (object.serverInfo !== undefined && object.serverInfo !== null)
      ? McpServerInfo.fromPartial(object.serverInfo)
      : undefined;
    return message;
  },
};

function createBaseMcpToolInfo(): McpToolInfo {
  return { name: "", description: "", inputSchemaJson: "" };
}

export const McpToolInfo: MessageFns<McpToolInfo> = {
  fromJSON(object: any): McpToolInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      inputSchemaJson: isSet(object.inputSchemaJson)
        ? globalThis.String(object.inputSchemaJson)
        : isSet(object.input_schema_json)
        ? globalThis.String(object.input_schema_json)
        : "",
    };
  },

  toJSON(message: McpToolInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.inputSchemaJson !== "") {
      obj.inputSchemaJson = message.inputSchemaJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpToolInfo>, I>>(base?: I): McpToolInfo {
    return McpToolInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpToolInfo>, I>>(object: I): McpToolInfo {
    const message = createBaseMcpToolInfo();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.inputSchemaJson = object.inputSchemaJson ?? "";
    return message;
  },
};

function createBaseMcpToolsListResult(): McpToolsListResult {
  return { tools: [] };
}

export const McpToolsListResult: MessageFns<McpToolsListResult> = {
  fromJSON(object: any): McpToolsListResult {
    return {
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => McpToolInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: McpToolsListResult): unknown {
    const obj: any = {};
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => McpToolInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpToolsListResult>, I>>(base?: I): McpToolsListResult {
    return McpToolsListResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpToolsListResult>, I>>(object: I): McpToolsListResult {
    const message = createBaseMcpToolsListResult();
    message.tools = object.tools?.map((e) => McpToolInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMcpContentBlock(): McpContentBlock {
  return { type: "", text: "" };
}

export const McpContentBlock: MessageFns<McpContentBlock> = {
  fromJSON(object: any): McpContentBlock {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: McpContentBlock): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpContentBlock>, I>>(base?: I): McpContentBlock {
    return McpContentBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpContentBlock>, I>>(object: I): McpContentBlock {
    const message = createBaseMcpContentBlock();
    message.type = object.type ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseMcpToolResult(): McpToolResult {
  return { content: [], isError: false };
}

export const McpToolResult: MessageFns<McpToolResult> = {
  fromJSON(object: any): McpToolResult {
    return {
      content: globalThis.Array.isArray(object?.content)
        ? object.content.map((e: any) => McpContentBlock.fromJSON(e))
        : [],
      isError: isSet(object.isError)
        ? globalThis.Boolean(object.isError)
        : isSet(object.is_error)
        ? globalThis.Boolean(object.is_error)
        : false,
    };
  },

  toJSON(message: McpToolResult): unknown {
    const obj: any = {};
    if (message.content?.length) {
      obj.content = message.content.map((e) => McpContentBlock.toJSON(e));
    }
    if (message.isError !== false) {
      obj.isError = message.isError;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpToolResult>, I>>(base?: I): McpToolResult {
    return McpToolResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpToolResult>, I>>(object: I): McpToolResult {
    const message = createBaseMcpToolResult();
    message.content = object.content?.map((e) => McpContentBlock.fromPartial(e)) || [];
    message.isError = object.isError ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
