// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               v5.28.3
// source: ink/event/event.proto

/* eslint-disable */
import { AssetRef, VoiceRef } from "../asset/asset";

export const protobufPackage = "ink.event.model";

export enum InventoryAction {
  INVENTORY_ACTION_UNSPECIFIED = 0,
  EQUIP = 1,
  UNEQUIP = 2,
  ADD = 3,
  REMOVE = 4,
  USE = 5,
  DROP = 6,
  UNRECOGNIZED = -1,
}

export function inventoryActionFromJSON(object: any): InventoryAction {
  switch (object) {
    case 0:
    case "INVENTORY_ACTION_UNSPECIFIED":
      return InventoryAction.INVENTORY_ACTION_UNSPECIFIED;
    case 1:
    case "EQUIP":
      return InventoryAction.EQUIP;
    case 2:
    case "UNEQUIP":
      return InventoryAction.UNEQUIP;
    case 3:
    case "ADD":
      return InventoryAction.ADD;
    case 4:
    case "REMOVE":
      return InventoryAction.REMOVE;
    case 5:
    case "USE":
      return InventoryAction.USE;
    case 6:
    case "DROP":
      return InventoryAction.DROP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InventoryAction.UNRECOGNIZED;
  }
}

export function inventoryActionToJSON(object: InventoryAction): string {
  switch (object) {
    case InventoryAction.INVENTORY_ACTION_UNSPECIFIED:
      return "INVENTORY_ACTION_UNSPECIFIED";
    case InventoryAction.EQUIP:
      return "EQUIP";
    case InventoryAction.UNEQUIP:
      return "UNEQUIP";
    case InventoryAction.ADD:
      return "ADD";
    case InventoryAction.REMOVE:
      return "REMOVE";
    case InventoryAction.USE:
      return "USE";
    case InventoryAction.DROP:
      return "DROP";
    case InventoryAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LoadPriority {
  LOAD_PRIORITY_UNSPECIFIED = 0,
  IMMEDIATE = 1,
  PRELOAD = 2,
  LAZY = 3,
  UNRECOGNIZED = -1,
}

export function loadPriorityFromJSON(object: any): LoadPriority {
  switch (object) {
    case 0:
    case "LOAD_PRIORITY_UNSPECIFIED":
      return LoadPriority.LOAD_PRIORITY_UNSPECIFIED;
    case 1:
    case "IMMEDIATE":
      return LoadPriority.IMMEDIATE;
    case 2:
    case "PRELOAD":
      return LoadPriority.PRELOAD;
    case 3:
    case "LAZY":
      return LoadPriority.LAZY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadPriority.UNRECOGNIZED;
  }
}

export function loadPriorityToJSON(object: LoadPriority): string {
  switch (object) {
    case LoadPriority.LOAD_PRIORITY_UNSPECIFIED:
      return "LOAD_PRIORITY_UNSPECIFIED";
    case LoadPriority.IMMEDIATE:
      return "IMMEDIATE";
    case LoadPriority.PRELOAD:
      return "PRELOAD";
    case LoadPriority.LAZY:
      return "LAZY";
    case LoadPriority.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AssetEvent {
  sessionId: string;
  /** equip, unequip, use, spawn, despawn */
  eventType: string;
  asset: AssetRef | undefined;
  timestamp: number;
}

export interface InventoryChangeEvent {
  sessionId: string;
  /** equip, unequip, add, remove, use, drop */
  action: string;
  emoji: string;
  asset: AssetRef | undefined;
  timestamp: number;
  /** human-readable item name */
  itemName: string;
}

export interface InkTagEvent {
  sessionId: string;
  tags: string[];
  knot: string;
  timestamp: number;
  /** assets resolved from tags */
  resolvedAssets: AssetRef[];
}

export interface AssetLoadRequest {
  sessionId: string;
  asset:
    | AssetRef
    | undefined;
  /** "IMMEDIATE", "PRELOAD", "LAZY" */
  priority: string;
  timestamp: number;
}

export interface VoiceSynthRequest {
  sessionId: string;
  text: string;
  voiceRef:
    | VoiceRef
    | undefined;
  /** redundant with voice_ref.language â€” kept for compat */
  language: string;
  timestamp: number;
}

function createBaseAssetEvent(): AssetEvent {
  return { sessionId: "", eventType: "", asset: undefined, timestamp: 0 };
}

export const AssetEvent: MessageFns<AssetEvent> = {
  fromJSON(object: any): AssetEvent {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      eventType: isSet(object.eventType)
        ? globalThis.String(object.eventType)
        : isSet(object.event_type)
        ? globalThis.String(object.event_type)
        : "",
      asset: isSet(object.asset) ? AssetRef.fromJSON(object.asset) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: AssetEvent): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.asset !== undefined) {
      obj.asset = AssetRef.toJSON(message.asset);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetEvent>, I>>(base?: I): AssetEvent {
    return AssetEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetEvent>, I>>(object: I): AssetEvent {
    const message = createBaseAssetEvent();
    message.sessionId = object.sessionId ?? "";
    message.eventType = object.eventType ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? AssetRef.fromPartial(object.asset)
      : undefined;
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseInventoryChangeEvent(): InventoryChangeEvent {
  return { sessionId: "", action: "", emoji: "", asset: undefined, timestamp: 0, itemName: "" };
}

export const InventoryChangeEvent: MessageFns<InventoryChangeEvent> = {
  fromJSON(object: any): InventoryChangeEvent {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : "",
      asset: isSet(object.asset) ? AssetRef.fromJSON(object.asset) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      itemName: isSet(object.itemName)
        ? globalThis.String(object.itemName)
        : isSet(object.item_name)
        ? globalThis.String(object.item_name)
        : "",
    };
  },

  toJSON(message: InventoryChangeEvent): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.emoji !== "") {
      obj.emoji = message.emoji;
    }
    if (message.asset !== undefined) {
      obj.asset = AssetRef.toJSON(message.asset);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.itemName !== "") {
      obj.itemName = message.itemName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InventoryChangeEvent>, I>>(base?: I): InventoryChangeEvent {
    return InventoryChangeEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InventoryChangeEvent>, I>>(object: I): InventoryChangeEvent {
    const message = createBaseInventoryChangeEvent();
    message.sessionId = object.sessionId ?? "";
    message.action = object.action ?? "";
    message.emoji = object.emoji ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? AssetRef.fromPartial(object.asset)
      : undefined;
    message.timestamp = object.timestamp ?? 0;
    message.itemName = object.itemName ?? "";
    return message;
  },
};

function createBaseInkTagEvent(): InkTagEvent {
  return { sessionId: "", tags: [], knot: "", timestamp: 0, resolvedAssets: [] };
}

export const InkTagEvent: MessageFns<InkTagEvent> = {
  fromJSON(object: any): InkTagEvent {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      knot: isSet(object.knot) ? globalThis.String(object.knot) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      resolvedAssets: globalThis.Array.isArray(object?.resolvedAssets)
        ? object.resolvedAssets.map((e: any) => AssetRef.fromJSON(e))
        : globalThis.Array.isArray(object?.resolved_assets)
        ? object.resolved_assets.map((e: any) => AssetRef.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InkTagEvent): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.knot !== "") {
      obj.knot = message.knot;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.resolvedAssets?.length) {
      obj.resolvedAssets = message.resolvedAssets.map((e) => AssetRef.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InkTagEvent>, I>>(base?: I): InkTagEvent {
    return InkTagEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InkTagEvent>, I>>(object: I): InkTagEvent {
    const message = createBaseInkTagEvent();
    message.sessionId = object.sessionId ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.knot = object.knot ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.resolvedAssets = object.resolvedAssets?.map((e) => AssetRef.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAssetLoadRequest(): AssetLoadRequest {
  return { sessionId: "", asset: undefined, priority: "", timestamp: 0 };
}

export const AssetLoadRequest: MessageFns<AssetLoadRequest> = {
  fromJSON(object: any): AssetLoadRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      asset: isSet(object.asset) ? AssetRef.fromJSON(object.asset) : undefined,
      priority: isSet(object.priority) ? globalThis.String(object.priority) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: AssetLoadRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.asset !== undefined) {
      obj.asset = AssetRef.toJSON(message.asset);
    }
    if (message.priority !== "") {
      obj.priority = message.priority;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetLoadRequest>, I>>(base?: I): AssetLoadRequest {
    return AssetLoadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetLoadRequest>, I>>(object: I): AssetLoadRequest {
    const message = createBaseAssetLoadRequest();
    message.sessionId = object.sessionId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? AssetRef.fromPartial(object.asset)
      : undefined;
    message.priority = object.priority ?? "";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseVoiceSynthRequest(): VoiceSynthRequest {
  return { sessionId: "", text: "", voiceRef: undefined, language: "", timestamp: 0 };
}

export const VoiceSynthRequest: MessageFns<VoiceSynthRequest> = {
  fromJSON(object: any): VoiceSynthRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      voiceRef: isSet(object.voiceRef)
        ? VoiceRef.fromJSON(object.voiceRef)
        : isSet(object.voice_ref)
        ? VoiceRef.fromJSON(object.voice_ref)
        : undefined,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: VoiceSynthRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.voiceRef !== undefined) {
      obj.voiceRef = VoiceRef.toJSON(message.voiceRef);
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceSynthRequest>, I>>(base?: I): VoiceSynthRequest {
    return VoiceSynthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceSynthRequest>, I>>(object: I): VoiceSynthRequest {
    const message = createBaseVoiceSynthRequest();
    message.sessionId = object.sessionId ?? "";
    message.text = object.text ?? "";
    message.voiceRef = (object.voiceRef !== undefined && object.voiceRef !== null)
      ? VoiceRef.fromPartial(object.voiceRef)
      : undefined;
    message.language = object.language ?? "";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
