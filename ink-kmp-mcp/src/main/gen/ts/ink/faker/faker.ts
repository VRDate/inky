// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               v5.28.3
// source: ink/faker/faker.proto

/* eslint-disable */

export const protobufPackage = "ink.faker.model";

export interface FakerConfig {
  /** Deterministic seed for kotlin.random.Random */
  seed: number;
  /** "en", "he", "de" */
  locale: string;
  /** Number of rows to generate */
  count: number;
  /** Game level for per-level stat modifiers */
  level: number;
  /** Filter by emoji category names */
  categories: string[];
}

export interface EmojiCategory {
  /** "üó°Ô∏è" */
  emoji: string;
  /** "game.elderScrolls.weapon" */
  fakerProvider: string;
  /** "name" */
  methodChain: string;
  /** Min value for random stat range */
  rangeMin: number;
  /** Max value for random stat range */
  rangeMax: number;
}

function createBaseFakerConfig(): FakerConfig {
  return { seed: 0, locale: "", count: 0, level: 0, categories: [] };
}

export const FakerConfig: MessageFns<FakerConfig> = {
  fromJSON(object: any): FakerConfig {
    return {
      seed: isSet(object.seed) ? globalThis.Number(object.seed) : 0,
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FakerConfig): unknown {
    const obj: any = {};
    if (message.seed !== 0) {
      obj.seed = Math.round(message.seed);
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FakerConfig>, I>>(base?: I): FakerConfig {
    return FakerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FakerConfig>, I>>(object: I): FakerConfig {
    const message = createBaseFakerConfig();
    message.seed = object.seed ?? 0;
    message.locale = object.locale ?? "";
    message.count = object.count ?? 0;
    message.level = object.level ?? 0;
    message.categories = object.categories?.map((e) => e) || [];
    return message;
  },
};

function createBaseEmojiCategory(): EmojiCategory {
  return { emoji: "", fakerProvider: "", methodChain: "", rangeMin: 0, rangeMax: 0 };
}

export const EmojiCategory: MessageFns<EmojiCategory> = {
  fromJSON(object: any): EmojiCategory {
    return {
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : "",
      fakerProvider: isSet(object.fakerProvider)
        ? globalThis.String(object.fakerProvider)
        : isSet(object.faker_provider)
        ? globalThis.String(object.faker_provider)
        : "",
      methodChain: isSet(object.methodChain)
        ? globalThis.String(object.methodChain)
        : isSet(object.method_chain)
        ? globalThis.String(object.method_chain)
        : "",
      rangeMin: isSet(object.rangeMin)
        ? globalThis.Number(object.rangeMin)
        : isSet(object.range_min)
        ? globalThis.Number(object.range_min)
        : 0,
      rangeMax: isSet(object.rangeMax)
        ? globalThis.Number(object.rangeMax)
        : isSet(object.range_max)
        ? globalThis.Number(object.range_max)
        : 0,
    };
  },

  toJSON(message: EmojiCategory): unknown {
    const obj: any = {};
    if (message.emoji !== "") {
      obj.emoji = message.emoji;
    }
    if (message.fakerProvider !== "") {
      obj.fakerProvider = message.fakerProvider;
    }
    if (message.methodChain !== "") {
      obj.methodChain = message.methodChain;
    }
    if (message.rangeMin !== 0) {
      obj.rangeMin = Math.round(message.rangeMin);
    }
    if (message.rangeMax !== 0) {
      obj.rangeMax = Math.round(message.rangeMax);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmojiCategory>, I>>(base?: I): EmojiCategory {
    return EmojiCategory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmojiCategory>, I>>(object: I): EmojiCategory {
    const message = createBaseEmojiCategory();
    message.emoji = object.emoji ?? "";
    message.fakerProvider = object.fakerProvider ?? "";
    message.methodChain = object.methodChain ?? "";
    message.rangeMin = object.rangeMin ?? 0;
    message.rangeMax = object.rangeMax ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
