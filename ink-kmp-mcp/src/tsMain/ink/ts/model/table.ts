// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               v5.28.3
// source: ink/model/table.proto

/* eslint-disable */

export const protobufPackage = "ink.model";

export enum CellType {
  STRING = 0,
  INT = 1,
  FLOAT = 2,
  BOOL = 3,
  /** FORMULA - POI XLSX formula (e.g. "=D2+E2*F2") */
  FORMULA = 4,
  /** EMOJI - Emoji category reference (resolved by EmojiAssetManifest) */
  EMOJI = 5,
  /** FAKER - Faker method placeholder (resolved by InkFakerEngine) */
  FAKER = 6,
  UNRECOGNIZED = -1,
}

export function cellTypeFromJSON(object: any): CellType {
  switch (object) {
    case 0:
    case "STRING":
      return CellType.STRING;
    case 1:
    case "INT":
      return CellType.INT;
    case 2:
    case "FLOAT":
      return CellType.FLOAT;
    case 3:
    case "BOOL":
      return CellType.BOOL;
    case 4:
    case "FORMULA":
      return CellType.FORMULA;
    case 5:
    case "EMOJI":
      return CellType.EMOJI;
    case 6:
    case "FAKER":
      return CellType.FAKER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CellType.UNRECOGNIZED;
  }
}

export function cellTypeToJSON(object: CellType): string {
  switch (object) {
    case CellType.STRING:
      return "STRING";
    case CellType.INT:
      return "INT";
    case CellType.FLOAT:
      return "FLOAT";
    case CellType.BOOL:
      return "BOOL";
    case CellType.FORMULA:
      return "FORMULA";
    case CellType.EMOJI:
      return "EMOJI";
    case CellType.FAKER:
      return "FAKER";
    case CellType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MdCell {
  /** Raw text value */
  value: string;
  /** POI formula (when type=FORMULA) */
  formula: string;
  /** Computed result after POI evaluation */
  evaluated: string;
  type: CellType;
}

export interface MdRow {
  /** column_name â†’ typed cell */
  cells: { [key: string]: MdCell };
}

export interface MdRow_CellsEntry {
  key: string;
  value: MdCell | undefined;
}

export interface MdTable {
  name: string;
  /** Dynamic column names */
  columns: string[];
  rows: MdRow[];
}

function createBaseMdCell(): MdCell {
  return { value: "", formula: "", evaluated: "", type: 0 };
}

export const MdCell: MessageFns<MdCell> = {
  fromJSON(object: any): MdCell {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      formula: isSet(object.formula) ? globalThis.String(object.formula) : "",
      evaluated: isSet(object.evaluated) ? globalThis.String(object.evaluated) : "",
      type: isSet(object.type) ? cellTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: MdCell): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.formula !== "") {
      obj.formula = message.formula;
    }
    if (message.evaluated !== "") {
      obj.evaluated = message.evaluated;
    }
    if (message.type !== 0) {
      obj.type = cellTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MdCell>, I>>(base?: I): MdCell {
    return MdCell.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MdCell>, I>>(object: I): MdCell {
    const message = createBaseMdCell();
    message.value = object.value ?? "";
    message.formula = object.formula ?? "";
    message.evaluated = object.evaluated ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseMdRow(): MdRow {
  return { cells: {} };
}

export const MdRow: MessageFns<MdRow> = {
  fromJSON(object: any): MdRow {
    return {
      cells: isObject(object.cells)
        ? (globalThis.Object.entries(object.cells) as [string, any][]).reduce(
          (acc: { [key: string]: MdCell }, [key, value]: [string, any]) => {
            acc[key] = MdCell.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: MdRow): unknown {
    const obj: any = {};
    if (message.cells) {
      const entries = globalThis.Object.entries(message.cells) as [string, MdCell][];
      if (entries.length > 0) {
        obj.cells = {};
        entries.forEach(([k, v]) => {
          obj.cells[k] = MdCell.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MdRow>, I>>(base?: I): MdRow {
    return MdRow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MdRow>, I>>(object: I): MdRow {
    const message = createBaseMdRow();
    message.cells = (globalThis.Object.entries(object.cells ?? {}) as [string, MdCell][]).reduce(
      (acc: { [key: string]: MdCell }, [key, value]: [string, MdCell]) => {
        if (value !== undefined) {
          acc[key] = MdCell.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMdRow_CellsEntry(): MdRow_CellsEntry {
  return { key: "", value: undefined };
}

export const MdRow_CellsEntry: MessageFns<MdRow_CellsEntry> = {
  fromJSON(object: any): MdRow_CellsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MdCell.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MdRow_CellsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MdCell.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MdRow_CellsEntry>, I>>(base?: I): MdRow_CellsEntry {
    return MdRow_CellsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MdRow_CellsEntry>, I>>(object: I): MdRow_CellsEntry {
    const message = createBaseMdRow_CellsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MdCell.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMdTable(): MdTable {
  return { name: "", columns: [], rows: [] };
}

export const MdTable: MessageFns<MdTable> = {
  fromJSON(object: any): MdTable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => MdRow.fromJSON(e)) : [],
    };
  },

  toJSON(message: MdTable): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => MdRow.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MdTable>, I>>(base?: I): MdTable {
    return MdTable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MdTable>, I>>(object: I): MdTable {
    const message = createBaseMdTable();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.rows = object.rows?.map((e) => MdRow.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
