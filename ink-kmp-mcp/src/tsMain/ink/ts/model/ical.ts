// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               v5.28.3
// source: ink/model/ical.proto

/* eslint-disable */

export const protobufPackage = "ink.model";

export enum EventStatus {
  EVENT_STATUS_UNSPECIFIED = 0,
  TENTATIVE = 1,
  CONFIRMED = 2,
  CANCELLED = 3,
  UNRECOGNIZED = -1,
}

export function eventStatusFromJSON(object: any): EventStatus {
  switch (object) {
    case 0:
    case "EVENT_STATUS_UNSPECIFIED":
      return EventStatus.EVENT_STATUS_UNSPECIFIED;
    case 1:
    case "TENTATIVE":
      return EventStatus.TENTATIVE;
    case 2:
    case "CONFIRMED":
      return EventStatus.CONFIRMED;
    case 3:
    case "CANCELLED":
      return EventStatus.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventStatus.UNRECOGNIZED;
  }
}

export function eventStatusToJSON(object: EventStatus): string {
  switch (object) {
    case EventStatus.EVENT_STATUS_UNSPECIFIED:
      return "EVENT_STATUS_UNSPECIFIED";
    case EventStatus.TENTATIVE:
      return "TENTATIVE";
    case EventStatus.CONFIRMED:
      return "CONFIRMED";
    case EventStatus.CANCELLED:
      return "CANCELLED";
    case EventStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TodoStatus {
  TODO_STATUS_UNSPECIFIED = 0,
  NEEDS_ACTION = 1,
  COMPLETED = 2,
  IN_PROCESS = 3,
  TODO_CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function todoStatusFromJSON(object: any): TodoStatus {
  switch (object) {
    case 0:
    case "TODO_STATUS_UNSPECIFIED":
      return TodoStatus.TODO_STATUS_UNSPECIFIED;
    case 1:
    case "NEEDS_ACTION":
      return TodoStatus.NEEDS_ACTION;
    case 2:
    case "COMPLETED":
      return TodoStatus.COMPLETED;
    case 3:
    case "IN_PROCESS":
      return TodoStatus.IN_PROCESS;
    case 4:
    case "TODO_CANCELLED":
      return TodoStatus.TODO_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TodoStatus.UNRECOGNIZED;
  }
}

export function todoStatusToJSON(object: TodoStatus): string {
  switch (object) {
    case TodoStatus.TODO_STATUS_UNSPECIFIED:
      return "TODO_STATUS_UNSPECIFIED";
    case TodoStatus.NEEDS_ACTION:
      return "NEEDS_ACTION";
    case TodoStatus.COMPLETED:
      return "COMPLETED";
    case TodoStatus.IN_PROCESS:
      return "IN_PROCESS";
    case TodoStatus.TODO_CANCELLED:
      return "TODO_CANCELLED";
    case TodoStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ParticipationStatus {
  PARTSTAT_UNSPECIFIED = 0,
  ACCEPTED = 1,
  DECLINED = 2,
  TENTATIVE_PARTSTAT = 3,
  DELEGATED = 4,
  NEEDS_ACTION_PARTSTAT = 5,
  UNRECOGNIZED = -1,
}

export function participationStatusFromJSON(object: any): ParticipationStatus {
  switch (object) {
    case 0:
    case "PARTSTAT_UNSPECIFIED":
      return ParticipationStatus.PARTSTAT_UNSPECIFIED;
    case 1:
    case "ACCEPTED":
      return ParticipationStatus.ACCEPTED;
    case 2:
    case "DECLINED":
      return ParticipationStatus.DECLINED;
    case 3:
    case "TENTATIVE_PARTSTAT":
      return ParticipationStatus.TENTATIVE_PARTSTAT;
    case 4:
    case "DELEGATED":
      return ParticipationStatus.DELEGATED;
    case 5:
    case "NEEDS_ACTION_PARTSTAT":
      return ParticipationStatus.NEEDS_ACTION_PARTSTAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParticipationStatus.UNRECOGNIZED;
  }
}

export function participationStatusToJSON(object: ParticipationStatus): string {
  switch (object) {
    case ParticipationStatus.PARTSTAT_UNSPECIFIED:
      return "PARTSTAT_UNSPECIFIED";
    case ParticipationStatus.ACCEPTED:
      return "ACCEPTED";
    case ParticipationStatus.DECLINED:
      return "DECLINED";
    case ParticipationStatus.TENTATIVE_PARTSTAT:
      return "TENTATIVE_PARTSTAT";
    case ParticipationStatus.DELEGATED:
      return "DELEGATED";
    case ParticipationStatus.NEEDS_ACTION_PARTSTAT:
      return "NEEDS_ACTION_PARTSTAT";
    case ParticipationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ParticipantRole {
  ROLE_UNSPECIFIED = 0,
  CHAIR = 1,
  /** REQ_PARTICIPANT - Required participant */
  REQ_PARTICIPANT = 2,
  /** OPT_PARTICIPANT - Optional participant */
  OPT_PARTICIPANT = 3,
  NON_PARTICIPANT = 4,
  UNRECOGNIZED = -1,
}

export function participantRoleFromJSON(object: any): ParticipantRole {
  switch (object) {
    case 0:
    case "ROLE_UNSPECIFIED":
      return ParticipantRole.ROLE_UNSPECIFIED;
    case 1:
    case "CHAIR":
      return ParticipantRole.CHAIR;
    case 2:
    case "REQ_PARTICIPANT":
      return ParticipantRole.REQ_PARTICIPANT;
    case 3:
    case "OPT_PARTICIPANT":
      return ParticipantRole.OPT_PARTICIPANT;
    case 4:
    case "NON_PARTICIPANT":
      return ParticipantRole.NON_PARTICIPANT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParticipantRole.UNRECOGNIZED;
  }
}

export function participantRoleToJSON(object: ParticipantRole): string {
  switch (object) {
    case ParticipantRole.ROLE_UNSPECIFIED:
      return "ROLE_UNSPECIFIED";
    case ParticipantRole.CHAIR:
      return "CHAIR";
    case ParticipantRole.REQ_PARTICIPANT:
      return "REQ_PARTICIPANT";
    case ParticipantRole.OPT_PARTICIPANT:
      return "OPT_PARTICIPANT";
    case ParticipantRole.NON_PARTICIPANT:
      return "NON_PARTICIPANT";
    case ParticipantRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RecurrenceFrequency {
  FREQ_UNSPECIFIED = 0,
  SECONDLY = 1,
  MINUTELY = 2,
  HOURLY = 3,
  DAILY = 4,
  WEEKLY = 5,
  MONTHLY = 6,
  YEARLY = 7,
  UNRECOGNIZED = -1,
}

export function recurrenceFrequencyFromJSON(object: any): RecurrenceFrequency {
  switch (object) {
    case 0:
    case "FREQ_UNSPECIFIED":
      return RecurrenceFrequency.FREQ_UNSPECIFIED;
    case 1:
    case "SECONDLY":
      return RecurrenceFrequency.SECONDLY;
    case 2:
    case "MINUTELY":
      return RecurrenceFrequency.MINUTELY;
    case 3:
    case "HOURLY":
      return RecurrenceFrequency.HOURLY;
    case 4:
    case "DAILY":
      return RecurrenceFrequency.DAILY;
    case 5:
    case "WEEKLY":
      return RecurrenceFrequency.WEEKLY;
    case 6:
    case "MONTHLY":
      return RecurrenceFrequency.MONTHLY;
    case 7:
    case "YEARLY":
      return RecurrenceFrequency.YEARLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecurrenceFrequency.UNRECOGNIZED;
  }
}

export function recurrenceFrequencyToJSON(object: RecurrenceFrequency): string {
  switch (object) {
    case RecurrenceFrequency.FREQ_UNSPECIFIED:
      return "FREQ_UNSPECIFIED";
    case RecurrenceFrequency.SECONDLY:
      return "SECONDLY";
    case RecurrenceFrequency.MINUTELY:
      return "MINUTELY";
    case RecurrenceFrequency.HOURLY:
      return "HOURLY";
    case RecurrenceFrequency.DAILY:
      return "DAILY";
    case RecurrenceFrequency.WEEKLY:
      return "WEEKLY";
    case RecurrenceFrequency.MONTHLY:
      return "MONTHLY";
    case RecurrenceFrequency.YEARLY:
      return "YEARLY";
    case RecurrenceFrequency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Weekday {
  WEEKDAY_UNSPECIFIED = 0,
  MO = 1,
  TU = 2,
  WE = 3,
  TH = 4,
  FR = 5,
  SA = 6,
  SU = 7,
  UNRECOGNIZED = -1,
}

export function weekdayFromJSON(object: any): Weekday {
  switch (object) {
    case 0:
    case "WEEKDAY_UNSPECIFIED":
      return Weekday.WEEKDAY_UNSPECIFIED;
    case 1:
    case "MO":
      return Weekday.MO;
    case 2:
    case "TU":
      return Weekday.TU;
    case 3:
    case "WE":
      return Weekday.WE;
    case 4:
    case "TH":
      return Weekday.TH;
    case 5:
    case "FR":
      return Weekday.FR;
    case 6:
    case "SA":
      return Weekday.SA;
    case 7:
    case "SU":
      return Weekday.SU;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Weekday.UNRECOGNIZED;
  }
}

export function weekdayToJSON(object: Weekday): string {
  switch (object) {
    case Weekday.WEEKDAY_UNSPECIFIED:
      return "WEEKDAY_UNSPECIFIED";
    case Weekday.MO:
      return "MO";
    case Weekday.TU:
      return "TU";
    case Weekday.WE:
      return "WE";
    case Weekday.TH:
      return "TH";
    case Weekday.FR:
      return "FR";
    case Weekday.SA:
      return "SA";
    case Weekday.SU:
      return "SU";
    case Weekday.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AlarmAction {
  ALARM_ACTION_UNSPECIFIED = 0,
  /** DISPLAY - Display notification */
  DISPLAY = 1,
  /** AUDIO - Play sound */
  AUDIO = 2,
  /** EMAIL - Send email */
  EMAIL = 3,
  UNRECOGNIZED = -1,
}

export function alarmActionFromJSON(object: any): AlarmAction {
  switch (object) {
    case 0:
    case "ALARM_ACTION_UNSPECIFIED":
      return AlarmAction.ALARM_ACTION_UNSPECIFIED;
    case 1:
    case "DISPLAY":
      return AlarmAction.DISPLAY;
    case 2:
    case "AUDIO":
      return AlarmAction.AUDIO;
    case 3:
    case "EMAIL":
      return AlarmAction.EMAIL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlarmAction.UNRECOGNIZED;
  }
}

export function alarmActionToJSON(object: AlarmAction): string {
  switch (object) {
    case AlarmAction.ALARM_ACTION_UNSPECIFIED:
      return "ALARM_ACTION_UNSPECIFIED";
    case AlarmAction.DISPLAY:
      return "DISPLAY";
    case AlarmAction.AUDIO:
      return "AUDIO";
    case AlarmAction.EMAIL:
      return "EMAIL";
    case AlarmAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Transparency {
  TRANSP_UNSPECIFIED = 0,
  /** OPAQUE - Blocks time */
  OPAQUE = 1,
  /** TRANSPARENT - Does not block time */
  TRANSPARENT = 2,
  UNRECOGNIZED = -1,
}

export function transparencyFromJSON(object: any): Transparency {
  switch (object) {
    case 0:
    case "TRANSP_UNSPECIFIED":
      return Transparency.TRANSP_UNSPECIFIED;
    case 1:
    case "OPAQUE":
      return Transparency.OPAQUE;
    case 2:
    case "TRANSPARENT":
      return Transparency.TRANSPARENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transparency.UNRECOGNIZED;
  }
}

export function transparencyToJSON(object: Transparency): string {
  switch (object) {
    case Transparency.TRANSP_UNSPECIFIED:
      return "TRANSP_UNSPECIFIED";
    case Transparency.OPAQUE:
      return "OPAQUE";
    case Transparency.TRANSPARENT:
      return "TRANSPARENT";
    case Transparency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AccessClassification {
  CLASS_UNSPECIFIED = 0,
  PUBLIC = 1,
  PRIVATE = 2,
  CONFIDENTIAL = 3,
  UNRECOGNIZED = -1,
}

export function accessClassificationFromJSON(object: any): AccessClassification {
  switch (object) {
    case 0:
    case "CLASS_UNSPECIFIED":
      return AccessClassification.CLASS_UNSPECIFIED;
    case 1:
    case "PUBLIC":
      return AccessClassification.PUBLIC;
    case 2:
    case "PRIVATE":
      return AccessClassification.PRIVATE;
    case 3:
    case "CONFIDENTIAL":
      return AccessClassification.CONFIDENTIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessClassification.UNRECOGNIZED;
  }
}

export function accessClassificationToJSON(object: AccessClassification): string {
  switch (object) {
    case AccessClassification.CLASS_UNSPECIFIED:
      return "CLASS_UNSPECIFIED";
    case AccessClassification.PUBLIC:
      return "PUBLIC";
    case AccessClassification.PRIVATE:
      return "PRIVATE";
    case AccessClassification.CONFIDENTIAL:
      return "CONFIDENTIAL";
    case AccessClassification.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WeekdayNum {
  /** -1 = last, 1 = first, etc. (0 = every) */
  ordinal: number;
  day: Weekday;
}

export interface RecurrenceRule {
  freq: RecurrenceFrequency;
  /** Default 1 */
  interval: number;
  /** Number of occurrences (0 = unlimited) */
  count: number;
  /** End date (ISO 8601, exclusive with count) */
  until: string;
  /** BYDAY */
  byDay: WeekdayNum[];
  /** BYMONTHDAY (-31..31) */
  byMonthDay: number[];
  /** BYYEARDAY (-366..366) */
  byYearDay: number[];
  /** BYWEEKNO (-53..53) */
  byWeekNo: number[];
  /** BYMONTH (1..12) */
  byMonth: number[];
  /** BYSETPOS (-366..366) */
  bySetPos: number[];
  /** WKST (default MO) */
  weekStart: Weekday;
  /** BYHOUR (0..23) */
  byHour: number[];
  /** BYMINUTE (0..59) */
  byMinute: number[];
  /** BYSECOND (0..60) */
  bySecond: number[];
}

export interface Attendee {
  /** mailto:user@example.com */
  calAddress: string;
  /** CN parameter */
  commonName: string;
  role: ParticipantRole;
  partstat: ParticipationStatus;
  rsvp: boolean;
  /** DELEGATED-FROM */
  delegatedFrom: string;
  /** DELEGATED-TO */
  delegatedTo: string;
  /** SENT-BY */
  sentBy: string;
}

export interface Organizer {
  /** mailto:organizer@example.com */
  calAddress: string;
  /** CN parameter */
  commonName: string;
  sentBy: string;
}

export interface Alarm {
  action: AlarmAction;
  /** ICalDuration before event (e.g. "-PT15M") or absolute datetime */
  trigger: string;
  /** true = trigger is absolute datetime */
  triggerAbsolute: boolean;
  /** Display text or email body */
  description: string;
  /** Email subject (when action=EMAIL) */
  summary: string;
  /** REPEAT */
  repeatCount: number;
  /** DURATION between repeats */
  repeatDuration: string;
}

export interface ICalDuration {
  negative: boolean;
  weeks: number;
  days: number;
  hours: number;
  minutes: number;
  seconds: number;
}

export interface GeoPosition {
  latitude: number;
  longitude: number;
}

export interface VEvent {
  /** Identification */
  uid: string;
  /** SEQUENCE — modification counter */
  sequence: number;
  /** Date/Time */
  dtStart: string;
  /** Exclusive with duration */
  dtEnd: string;
  duration:
    | ICalDuration
    | undefined;
  /** DTSTAMP — creation timestamp */
  dtStamp: string;
  /** Description */
  summary: string;
  description: string;
  location: string;
  geo: GeoPosition | undefined;
  url: string;
  /** Status & Classification */
  status: EventStatus;
  classification: AccessClassification;
  transp: Transparency;
  /** 0 = undefined, 1 = highest, 9 = lowest */
  priority: number;
  /** Categories & Resources */
  categories: string[];
  resources: string[];
  /** Participants */
  organizer: Organizer | undefined;
  attendees: Attendee[];
  /** Recurrence (RFC 5545 §3.8.5) */
  rrule:
    | RecurrenceRule
    | undefined;
  /** RDATE — additional recurrence dates */
  rdate: string[];
  /** EXDATE — exception dates */
  exdate: string[];
  /** RECURRENCE-ID — override instance */
  recurrenceId: string;
  /** Alarms */
  alarms: Alarm[];
  /** Timestamps */
  created: string;
  /** LAST-MODIFIED */
  lastModified: string;
  /** Relationships */
  relatedTo: string;
  /** ATTACH — URIs */
  attachments: string[];
  /** RFC 7986 Extensions */
  color: string;
  /** CONFERENCE — video/voice URIs */
  conferences: string[];
}

export interface VTodo {
  uid: string;
  sequence: number;
  dtStart: string;
  /** DUE — completion deadline */
  due: string;
  duration:
    | ICalDuration
    | undefined;
  /** COMPLETED — actual completion datetime */
  completed: string;
  summary: string;
  description: string;
  location: string;
  status: TodoStatus;
  classification: AccessClassification;
  priority: number;
  /** PERCENT-COMPLETE (0..100) */
  percentComplete: number;
  categories: string[];
  organizer: Organizer | undefined;
  attendees: Attendee[];
  rrule: RecurrenceRule | undefined;
  alarms: Alarm[];
  created: string;
  lastModified: string;
  relatedTo: string;
}

export interface VJournal {
  uid: string;
  sequence: number;
  /** Date of journal entry */
  dtStart: string;
  summary: string;
  description: string;
  /** DRAFT, FINAL, CANCELLED */
  status: EventStatus;
  classification: AccessClassification;
  categories: string[];
  organizer: Organizer | undefined;
  attendees: Attendee[];
  rrule: RecurrenceRule | undefined;
  created: string;
  lastModified: string;
  relatedTo: string;
}

export interface VCalendar {
  /** PRODID — producer identifier */
  prodId: string;
  /** VERSION — "2.0" */
  version: string;
  /** CALSCALE — "GREGORIAN" */
  calScale: string;
  /** METHOD — iTIP method (PUBLISH, REQUEST, etc.) */
  method: string;
  /** RFC 7986 Extensions */
  name: string;
  description: string;
  /** COLOR — display color */
  color: string;
  /** SOURCE — subscription URL */
  source: string;
  /** REFRESH-INTERVAL — subscription refresh */
  refreshInterval: string;
  /** Components */
  events: VEvent[];
  todos: VTodo[];
  journals: VJournal[];
}

function createBaseWeekdayNum(): WeekdayNum {
  return { ordinal: 0, day: 0 };
}

export const WeekdayNum: MessageFns<WeekdayNum> = {
  fromJSON(object: any): WeekdayNum {
    return {
      ordinal: isSet(object.ordinal) ? globalThis.Number(object.ordinal) : 0,
      day: isSet(object.day) ? weekdayFromJSON(object.day) : 0,
    };
  },

  toJSON(message: WeekdayNum): unknown {
    const obj: any = {};
    if (message.ordinal !== 0) {
      obj.ordinal = Math.round(message.ordinal);
    }
    if (message.day !== 0) {
      obj.day = weekdayToJSON(message.day);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeekdayNum>, I>>(base?: I): WeekdayNum {
    return WeekdayNum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeekdayNum>, I>>(object: I): WeekdayNum {
    const message = createBaseWeekdayNum();
    message.ordinal = object.ordinal ?? 0;
    message.day = object.day ?? 0;
    return message;
  },
};

function createBaseRecurrenceRule(): RecurrenceRule {
  return {
    freq: 0,
    interval: 0,
    count: 0,
    until: "",
    byDay: [],
    byMonthDay: [],
    byYearDay: [],
    byWeekNo: [],
    byMonth: [],
    bySetPos: [],
    weekStart: 0,
    byHour: [],
    byMinute: [],
    bySecond: [],
  };
}

export const RecurrenceRule: MessageFns<RecurrenceRule> = {
  fromJSON(object: any): RecurrenceRule {
    return {
      freq: isSet(object.freq) ? recurrenceFrequencyFromJSON(object.freq) : 0,
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      until: isSet(object.until) ? globalThis.String(object.until) : "",
      byDay: globalThis.Array.isArray(object?.byDay)
        ? object.byDay.map((e: any) => WeekdayNum.fromJSON(e))
        : globalThis.Array.isArray(object?.by_day)
        ? object.by_day.map((e: any) => WeekdayNum.fromJSON(e))
        : [],
      byMonthDay: globalThis.Array.isArray(object?.byMonthDay)
        ? object.byMonthDay.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.by_month_day)
        ? object.by_month_day.map((e: any) => globalThis.Number(e))
        : [],
      byYearDay: globalThis.Array.isArray(object?.byYearDay)
        ? object.byYearDay.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.by_year_day)
        ? object.by_year_day.map((e: any) => globalThis.Number(e))
        : [],
      byWeekNo: globalThis.Array.isArray(object?.byWeekNo)
        ? object.byWeekNo.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.by_week_no)
        ? object.by_week_no.map((e: any) => globalThis.Number(e))
        : [],
      byMonth: globalThis.Array.isArray(object?.byMonth)
        ? object.byMonth.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.by_month)
        ? object.by_month.map((e: any) => globalThis.Number(e))
        : [],
      bySetPos: globalThis.Array.isArray(object?.bySetPos)
        ? object.bySetPos.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.by_set_pos)
        ? object.by_set_pos.map((e: any) => globalThis.Number(e))
        : [],
      weekStart: isSet(object.weekStart)
        ? weekdayFromJSON(object.weekStart)
        : isSet(object.week_start)
        ? weekdayFromJSON(object.week_start)
        : 0,
      byHour: globalThis.Array.isArray(object?.byHour)
        ? object.byHour.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.by_hour)
        ? object.by_hour.map((e: any) => globalThis.Number(e))
        : [],
      byMinute: globalThis.Array.isArray(object?.byMinute)
        ? object.byMinute.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.by_minute)
        ? object.by_minute.map((e: any) => globalThis.Number(e))
        : [],
      bySecond: globalThis.Array.isArray(object?.bySecond)
        ? object.bySecond.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.by_second)
        ? object.by_second.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: RecurrenceRule): unknown {
    const obj: any = {};
    if (message.freq !== 0) {
      obj.freq = recurrenceFrequencyToJSON(message.freq);
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.until !== "") {
      obj.until = message.until;
    }
    if (message.byDay?.length) {
      obj.byDay = message.byDay.map((e) => WeekdayNum.toJSON(e));
    }
    if (message.byMonthDay?.length) {
      obj.byMonthDay = message.byMonthDay.map((e) => Math.round(e));
    }
    if (message.byYearDay?.length) {
      obj.byYearDay = message.byYearDay.map((e) => Math.round(e));
    }
    if (message.byWeekNo?.length) {
      obj.byWeekNo = message.byWeekNo.map((e) => Math.round(e));
    }
    if (message.byMonth?.length) {
      obj.byMonth = message.byMonth.map((e) => Math.round(e));
    }
    if (message.bySetPos?.length) {
      obj.bySetPos = message.bySetPos.map((e) => Math.round(e));
    }
    if (message.weekStart !== 0) {
      obj.weekStart = weekdayToJSON(message.weekStart);
    }
    if (message.byHour?.length) {
      obj.byHour = message.byHour.map((e) => Math.round(e));
    }
    if (message.byMinute?.length) {
      obj.byMinute = message.byMinute.map((e) => Math.round(e));
    }
    if (message.bySecond?.length) {
      obj.bySecond = message.bySecond.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecurrenceRule>, I>>(base?: I): RecurrenceRule {
    return RecurrenceRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecurrenceRule>, I>>(object: I): RecurrenceRule {
    const message = createBaseRecurrenceRule();
    message.freq = object.freq ?? 0;
    message.interval = object.interval ?? 0;
    message.count = object.count ?? 0;
    message.until = object.until ?? "";
    message.byDay = object.byDay?.map((e) => WeekdayNum.fromPartial(e)) || [];
    message.byMonthDay = object.byMonthDay?.map((e) => e) || [];
    message.byYearDay = object.byYearDay?.map((e) => e) || [];
    message.byWeekNo = object.byWeekNo?.map((e) => e) || [];
    message.byMonth = object.byMonth?.map((e) => e) || [];
    message.bySetPos = object.bySetPos?.map((e) => e) || [];
    message.weekStart = object.weekStart ?? 0;
    message.byHour = object.byHour?.map((e) => e) || [];
    message.byMinute = object.byMinute?.map((e) => e) || [];
    message.bySecond = object.bySecond?.map((e) => e) || [];
    return message;
  },
};

function createBaseAttendee(): Attendee {
  return {
    calAddress: "",
    commonName: "",
    role: 0,
    partstat: 0,
    rsvp: false,
    delegatedFrom: "",
    delegatedTo: "",
    sentBy: "",
  };
}

export const Attendee: MessageFns<Attendee> = {
  fromJSON(object: any): Attendee {
    return {
      calAddress: isSet(object.calAddress)
        ? globalThis.String(object.calAddress)
        : isSet(object.cal_address)
        ? globalThis.String(object.cal_address)
        : "",
      commonName: isSet(object.commonName)
        ? globalThis.String(object.commonName)
        : isSet(object.common_name)
        ? globalThis.String(object.common_name)
        : "",
      role: isSet(object.role) ? participantRoleFromJSON(object.role) : 0,
      partstat: isSet(object.partstat) ? participationStatusFromJSON(object.partstat) : 0,
      rsvp: isSet(object.rsvp) ? globalThis.Boolean(object.rsvp) : false,
      delegatedFrom: isSet(object.delegatedFrom)
        ? globalThis.String(object.delegatedFrom)
        : isSet(object.delegated_from)
        ? globalThis.String(object.delegated_from)
        : "",
      delegatedTo: isSet(object.delegatedTo)
        ? globalThis.String(object.delegatedTo)
        : isSet(object.delegated_to)
        ? globalThis.String(object.delegated_to)
        : "",
      sentBy: isSet(object.sentBy)
        ? globalThis.String(object.sentBy)
        : isSet(object.sent_by)
        ? globalThis.String(object.sent_by)
        : "",
    };
  },

  toJSON(message: Attendee): unknown {
    const obj: any = {};
    if (message.calAddress !== "") {
      obj.calAddress = message.calAddress;
    }
    if (message.commonName !== "") {
      obj.commonName = message.commonName;
    }
    if (message.role !== 0) {
      obj.role = participantRoleToJSON(message.role);
    }
    if (message.partstat !== 0) {
      obj.partstat = participationStatusToJSON(message.partstat);
    }
    if (message.rsvp !== false) {
      obj.rsvp = message.rsvp;
    }
    if (message.delegatedFrom !== "") {
      obj.delegatedFrom = message.delegatedFrom;
    }
    if (message.delegatedTo !== "") {
      obj.delegatedTo = message.delegatedTo;
    }
    if (message.sentBy !== "") {
      obj.sentBy = message.sentBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attendee>, I>>(base?: I): Attendee {
    return Attendee.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attendee>, I>>(object: I): Attendee {
    const message = createBaseAttendee();
    message.calAddress = object.calAddress ?? "";
    message.commonName = object.commonName ?? "";
    message.role = object.role ?? 0;
    message.partstat = object.partstat ?? 0;
    message.rsvp = object.rsvp ?? false;
    message.delegatedFrom = object.delegatedFrom ?? "";
    message.delegatedTo = object.delegatedTo ?? "";
    message.sentBy = object.sentBy ?? "";
    return message;
  },
};

function createBaseOrganizer(): Organizer {
  return { calAddress: "", commonName: "", sentBy: "" };
}

export const Organizer: MessageFns<Organizer> = {
  fromJSON(object: any): Organizer {
    return {
      calAddress: isSet(object.calAddress)
        ? globalThis.String(object.calAddress)
        : isSet(object.cal_address)
        ? globalThis.String(object.cal_address)
        : "",
      commonName: isSet(object.commonName)
        ? globalThis.String(object.commonName)
        : isSet(object.common_name)
        ? globalThis.String(object.common_name)
        : "",
      sentBy: isSet(object.sentBy)
        ? globalThis.String(object.sentBy)
        : isSet(object.sent_by)
        ? globalThis.String(object.sent_by)
        : "",
    };
  },

  toJSON(message: Organizer): unknown {
    const obj: any = {};
    if (message.calAddress !== "") {
      obj.calAddress = message.calAddress;
    }
    if (message.commonName !== "") {
      obj.commonName = message.commonName;
    }
    if (message.sentBy !== "") {
      obj.sentBy = message.sentBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Organizer>, I>>(base?: I): Organizer {
    return Organizer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Organizer>, I>>(object: I): Organizer {
    const message = createBaseOrganizer();
    message.calAddress = object.calAddress ?? "";
    message.commonName = object.commonName ?? "";
    message.sentBy = object.sentBy ?? "";
    return message;
  },
};

function createBaseAlarm(): Alarm {
  return {
    action: 0,
    trigger: "",
    triggerAbsolute: false,
    description: "",
    summary: "",
    repeatCount: 0,
    repeatDuration: "",
  };
}

export const Alarm: MessageFns<Alarm> = {
  fromJSON(object: any): Alarm {
    return {
      action: isSet(object.action) ? alarmActionFromJSON(object.action) : 0,
      trigger: isSet(object.trigger) ? globalThis.String(object.trigger) : "",
      triggerAbsolute: isSet(object.triggerAbsolute)
        ? globalThis.Boolean(object.triggerAbsolute)
        : isSet(object.trigger_absolute)
        ? globalThis.Boolean(object.trigger_absolute)
        : false,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      repeatCount: isSet(object.repeatCount)
        ? globalThis.Number(object.repeatCount)
        : isSet(object.repeat_count)
        ? globalThis.Number(object.repeat_count)
        : 0,
      repeatDuration: isSet(object.repeatDuration)
        ? globalThis.String(object.repeatDuration)
        : isSet(object.repeat_duration)
        ? globalThis.String(object.repeat_duration)
        : "",
    };
  },

  toJSON(message: Alarm): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = alarmActionToJSON(message.action);
    }
    if (message.trigger !== "") {
      obj.trigger = message.trigger;
    }
    if (message.triggerAbsolute !== false) {
      obj.triggerAbsolute = message.triggerAbsolute;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.repeatCount !== 0) {
      obj.repeatCount = Math.round(message.repeatCount);
    }
    if (message.repeatDuration !== "") {
      obj.repeatDuration = message.repeatDuration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Alarm>, I>>(base?: I): Alarm {
    return Alarm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Alarm>, I>>(object: I): Alarm {
    const message = createBaseAlarm();
    message.action = object.action ?? 0;
    message.trigger = object.trigger ?? "";
    message.triggerAbsolute = object.triggerAbsolute ?? false;
    message.description = object.description ?? "";
    message.summary = object.summary ?? "";
    message.repeatCount = object.repeatCount ?? 0;
    message.repeatDuration = object.repeatDuration ?? "";
    return message;
  },
};

function createBaseICalDuration(): ICalDuration {
  return { negative: false, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0 };
}

export const ICalDuration: MessageFns<ICalDuration> = {
  fromJSON(object: any): ICalDuration {
    return {
      negative: isSet(object.negative) ? globalThis.Boolean(object.negative) : false,
      weeks: isSet(object.weeks) ? globalThis.Number(object.weeks) : 0,
      days: isSet(object.days) ? globalThis.Number(object.days) : 0,
      hours: isSet(object.hours) ? globalThis.Number(object.hours) : 0,
      minutes: isSet(object.minutes) ? globalThis.Number(object.minutes) : 0,
      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,
    };
  },

  toJSON(message: ICalDuration): unknown {
    const obj: any = {};
    if (message.negative !== false) {
      obj.negative = message.negative;
    }
    if (message.weeks !== 0) {
      obj.weeks = Math.round(message.weeks);
    }
    if (message.days !== 0) {
      obj.days = Math.round(message.days);
    }
    if (message.hours !== 0) {
      obj.hours = Math.round(message.hours);
    }
    if (message.minutes !== 0) {
      obj.minutes = Math.round(message.minutes);
    }
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ICalDuration>, I>>(base?: I): ICalDuration {
    return ICalDuration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ICalDuration>, I>>(object: I): ICalDuration {
    const message = createBaseICalDuration();
    message.negative = object.negative ?? false;
    message.weeks = object.weeks ?? 0;
    message.days = object.days ?? 0;
    message.hours = object.hours ?? 0;
    message.minutes = object.minutes ?? 0;
    message.seconds = object.seconds ?? 0;
    return message;
  },
};

function createBaseGeoPosition(): GeoPosition {
  return { latitude: 0, longitude: 0 };
}

export const GeoPosition: MessageFns<GeoPosition> = {
  fromJSON(object: any): GeoPosition {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
    };
  },

  toJSON(message: GeoPosition): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoPosition>, I>>(base?: I): GeoPosition {
    return GeoPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoPosition>, I>>(object: I): GeoPosition {
    const message = createBaseGeoPosition();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    return message;
  },
};

function createBaseVEvent(): VEvent {
  return {
    uid: "",
    sequence: 0,
    dtStart: "",
    dtEnd: "",
    duration: undefined,
    dtStamp: "",
    summary: "",
    description: "",
    location: "",
    geo: undefined,
    url: "",
    status: 0,
    classification: 0,
    transp: 0,
    priority: 0,
    categories: [],
    resources: [],
    organizer: undefined,
    attendees: [],
    rrule: undefined,
    rdate: [],
    exdate: [],
    recurrenceId: "",
    alarms: [],
    created: "",
    lastModified: "",
    relatedTo: "",
    attachments: [],
    color: "",
    conferences: [],
  };
}

export const VEvent: MessageFns<VEvent> = {
  fromJSON(object: any): VEvent {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      dtStart: isSet(object.dtStart)
        ? globalThis.String(object.dtStart)
        : isSet(object.dt_start)
        ? globalThis.String(object.dt_start)
        : "",
      dtEnd: isSet(object.dtEnd)
        ? globalThis.String(object.dtEnd)
        : isSet(object.dt_end)
        ? globalThis.String(object.dt_end)
        : "",
      duration: isSet(object.duration) ? ICalDuration.fromJSON(object.duration) : undefined,
      dtStamp: isSet(object.dtStamp)
        ? globalThis.String(object.dtStamp)
        : isSet(object.dt_stamp)
        ? globalThis.String(object.dt_stamp)
        : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      geo: isSet(object.geo) ? GeoPosition.fromJSON(object.geo) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      status: isSet(object.status) ? eventStatusFromJSON(object.status) : 0,
      classification: isSet(object.classification) ? accessClassificationFromJSON(object.classification) : 0,
      transp: isSet(object.transp) ? transparencyFromJSON(object.transp) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => globalThis.String(e))
        : [],
      organizer: isSet(object.organizer) ? Organizer.fromJSON(object.organizer) : undefined,
      attendees: globalThis.Array.isArray(object?.attendees)
        ? object.attendees.map((e: any) => Attendee.fromJSON(e))
        : [],
      rrule: isSet(object.rrule) ? RecurrenceRule.fromJSON(object.rrule) : undefined,
      rdate: globalThis.Array.isArray(object?.rdate)
        ? object.rdate.map((e: any) => globalThis.String(e))
        : [],
      exdate: globalThis.Array.isArray(object?.exdate) ? object.exdate.map((e: any) => globalThis.String(e)) : [],
      recurrenceId: isSet(object.recurrenceId)
        ? globalThis.String(object.recurrenceId)
        : isSet(object.recurrence_id)
        ? globalThis.String(object.recurrence_id)
        : "",
      alarms: globalThis.Array.isArray(object?.alarms) ? object.alarms.map((e: any) => Alarm.fromJSON(e)) : [],
      created: isSet(object.created) ? globalThis.String(object.created) : "",
      lastModified: isSet(object.lastModified)
        ? globalThis.String(object.lastModified)
        : isSet(object.last_modified)
        ? globalThis.String(object.last_modified)
        : "",
      relatedTo: isSet(object.relatedTo)
        ? globalThis.String(object.relatedTo)
        : isSet(object.related_to)
        ? globalThis.String(object.related_to)
        : "",
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => globalThis.String(e))
        : [],
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      conferences: globalThis.Array.isArray(object?.conferences)
        ? object.conferences.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: VEvent): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.dtStart !== "") {
      obj.dtStart = message.dtStart;
    }
    if (message.dtEnd !== "") {
      obj.dtEnd = message.dtEnd;
    }
    if (message.duration !== undefined) {
      obj.duration = ICalDuration.toJSON(message.duration);
    }
    if (message.dtStamp !== "") {
      obj.dtStamp = message.dtStamp;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.geo !== undefined) {
      obj.geo = GeoPosition.toJSON(message.geo);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.status !== 0) {
      obj.status = eventStatusToJSON(message.status);
    }
    if (message.classification !== 0) {
      obj.classification = accessClassificationToJSON(message.classification);
    }
    if (message.transp !== 0) {
      obj.transp = transparencyToJSON(message.transp);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.resources?.length) {
      obj.resources = message.resources;
    }
    if (message.organizer !== undefined) {
      obj.organizer = Organizer.toJSON(message.organizer);
    }
    if (message.attendees?.length) {
      obj.attendees = message.attendees.map((e) => Attendee.toJSON(e));
    }
    if (message.rrule !== undefined) {
      obj.rrule = RecurrenceRule.toJSON(message.rrule);
    }
    if (message.rdate?.length) {
      obj.rdate = message.rdate;
    }
    if (message.exdate?.length) {
      obj.exdate = message.exdate;
    }
    if (message.recurrenceId !== "") {
      obj.recurrenceId = message.recurrenceId;
    }
    if (message.alarms?.length) {
      obj.alarms = message.alarms.map((e) => Alarm.toJSON(e));
    }
    if (message.created !== "") {
      obj.created = message.created;
    }
    if (message.lastModified !== "") {
      obj.lastModified = message.lastModified;
    }
    if (message.relatedTo !== "") {
      obj.relatedTo = message.relatedTo;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.conferences?.length) {
      obj.conferences = message.conferences;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VEvent>, I>>(base?: I): VEvent {
    return VEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VEvent>, I>>(object: I): VEvent {
    const message = createBaseVEvent();
    message.uid = object.uid ?? "";
    message.sequence = object.sequence ?? 0;
    message.dtStart = object.dtStart ?? "";
    message.dtEnd = object.dtEnd ?? "";
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? ICalDuration.fromPartial(object.duration)
      : undefined;
    message.dtStamp = object.dtStamp ?? "";
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.location = object.location ?? "";
    message.geo = (object.geo !== undefined && object.geo !== null) ? GeoPosition.fromPartial(object.geo) : undefined;
    message.url = object.url ?? "";
    message.status = object.status ?? 0;
    message.classification = object.classification ?? 0;
    message.transp = object.transp ?? 0;
    message.priority = object.priority ?? 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.resources = object.resources?.map((e) => e) || [];
    message.organizer = (object.organizer !== undefined && object.organizer !== null)
      ? Organizer.fromPartial(object.organizer)
      : undefined;
    message.attendees = object.attendees?.map((e) => Attendee.fromPartial(e)) || [];
    message.rrule = (object.rrule !== undefined && object.rrule !== null)
      ? RecurrenceRule.fromPartial(object.rrule)
      : undefined;
    message.rdate = object.rdate?.map((e) => e) || [];
    message.exdate = object.exdate?.map((e) => e) || [];
    message.recurrenceId = object.recurrenceId ?? "";
    message.alarms = object.alarms?.map((e) => Alarm.fromPartial(e)) || [];
    message.created = object.created ?? "";
    message.lastModified = object.lastModified ?? "";
    message.relatedTo = object.relatedTo ?? "";
    message.attachments = object.attachments?.map((e) => e) || [];
    message.color = object.color ?? "";
    message.conferences = object.conferences?.map((e) => e) || [];
    return message;
  },
};

function createBaseVTodo(): VTodo {
  return {
    uid: "",
    sequence: 0,
    dtStart: "",
    due: "",
    duration: undefined,
    completed: "",
    summary: "",
    description: "",
    location: "",
    status: 0,
    classification: 0,
    priority: 0,
    percentComplete: 0,
    categories: [],
    organizer: undefined,
    attendees: [],
    rrule: undefined,
    alarms: [],
    created: "",
    lastModified: "",
    relatedTo: "",
  };
}

export const VTodo: MessageFns<VTodo> = {
  fromJSON(object: any): VTodo {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      dtStart: isSet(object.dtStart)
        ? globalThis.String(object.dtStart)
        : isSet(object.dt_start)
        ? globalThis.String(object.dt_start)
        : "",
      due: isSet(object.due) ? globalThis.String(object.due) : "",
      duration: isSet(object.duration) ? ICalDuration.fromJSON(object.duration) : undefined,
      completed: isSet(object.completed) ? globalThis.String(object.completed) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      status: isSet(object.status) ? todoStatusFromJSON(object.status) : 0,
      classification: isSet(object.classification) ? accessClassificationFromJSON(object.classification) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      percentComplete: isSet(object.percentComplete)
        ? globalThis.Number(object.percentComplete)
        : isSet(object.percent_complete)
        ? globalThis.Number(object.percent_complete)
        : 0,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      organizer: isSet(object.organizer) ? Organizer.fromJSON(object.organizer) : undefined,
      attendees: globalThis.Array.isArray(object?.attendees)
        ? object.attendees.map((e: any) => Attendee.fromJSON(e))
        : [],
      rrule: isSet(object.rrule) ? RecurrenceRule.fromJSON(object.rrule) : undefined,
      alarms: globalThis.Array.isArray(object?.alarms)
        ? object.alarms.map((e: any) => Alarm.fromJSON(e))
        : [],
      created: isSet(object.created) ? globalThis.String(object.created) : "",
      lastModified: isSet(object.lastModified)
        ? globalThis.String(object.lastModified)
        : isSet(object.last_modified)
        ? globalThis.String(object.last_modified)
        : "",
      relatedTo: isSet(object.relatedTo)
        ? globalThis.String(object.relatedTo)
        : isSet(object.related_to)
        ? globalThis.String(object.related_to)
        : "",
    };
  },

  toJSON(message: VTodo): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.dtStart !== "") {
      obj.dtStart = message.dtStart;
    }
    if (message.due !== "") {
      obj.due = message.due;
    }
    if (message.duration !== undefined) {
      obj.duration = ICalDuration.toJSON(message.duration);
    }
    if (message.completed !== "") {
      obj.completed = message.completed;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.status !== 0) {
      obj.status = todoStatusToJSON(message.status);
    }
    if (message.classification !== 0) {
      obj.classification = accessClassificationToJSON(message.classification);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.percentComplete !== 0) {
      obj.percentComplete = Math.round(message.percentComplete);
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.organizer !== undefined) {
      obj.organizer = Organizer.toJSON(message.organizer);
    }
    if (message.attendees?.length) {
      obj.attendees = message.attendees.map((e) => Attendee.toJSON(e));
    }
    if (message.rrule !== undefined) {
      obj.rrule = RecurrenceRule.toJSON(message.rrule);
    }
    if (message.alarms?.length) {
      obj.alarms = message.alarms.map((e) => Alarm.toJSON(e));
    }
    if (message.created !== "") {
      obj.created = message.created;
    }
    if (message.lastModified !== "") {
      obj.lastModified = message.lastModified;
    }
    if (message.relatedTo !== "") {
      obj.relatedTo = message.relatedTo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VTodo>, I>>(base?: I): VTodo {
    return VTodo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VTodo>, I>>(object: I): VTodo {
    const message = createBaseVTodo();
    message.uid = object.uid ?? "";
    message.sequence = object.sequence ?? 0;
    message.dtStart = object.dtStart ?? "";
    message.due = object.due ?? "";
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? ICalDuration.fromPartial(object.duration)
      : undefined;
    message.completed = object.completed ?? "";
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.location = object.location ?? "";
    message.status = object.status ?? 0;
    message.classification = object.classification ?? 0;
    message.priority = object.priority ?? 0;
    message.percentComplete = object.percentComplete ?? 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.organizer = (object.organizer !== undefined && object.organizer !== null)
      ? Organizer.fromPartial(object.organizer)
      : undefined;
    message.attendees = object.attendees?.map((e) => Attendee.fromPartial(e)) || [];
    message.rrule = (object.rrule !== undefined && object.rrule !== null)
      ? RecurrenceRule.fromPartial(object.rrule)
      : undefined;
    message.alarms = object.alarms?.map((e) => Alarm.fromPartial(e)) || [];
    message.created = object.created ?? "";
    message.lastModified = object.lastModified ?? "";
    message.relatedTo = object.relatedTo ?? "";
    return message;
  },
};

function createBaseVJournal(): VJournal {
  return {
    uid: "",
    sequence: 0,
    dtStart: "",
    summary: "",
    description: "",
    status: 0,
    classification: 0,
    categories: [],
    organizer: undefined,
    attendees: [],
    rrule: undefined,
    created: "",
    lastModified: "",
    relatedTo: "",
  };
}

export const VJournal: MessageFns<VJournal> = {
  fromJSON(object: any): VJournal {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      dtStart: isSet(object.dtStart)
        ? globalThis.String(object.dtStart)
        : isSet(object.dt_start)
        ? globalThis.String(object.dt_start)
        : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      status: isSet(object.status) ? eventStatusFromJSON(object.status) : 0,
      classification: isSet(object.classification) ? accessClassificationFromJSON(object.classification) : 0,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      organizer: isSet(object.organizer) ? Organizer.fromJSON(object.organizer) : undefined,
      attendees: globalThis.Array.isArray(object?.attendees)
        ? object.attendees.map((e: any) => Attendee.fromJSON(e))
        : [],
      rrule: isSet(object.rrule) ? RecurrenceRule.fromJSON(object.rrule) : undefined,
      created: isSet(object.created) ? globalThis.String(object.created) : "",
      lastModified: isSet(object.lastModified)
        ? globalThis.String(object.lastModified)
        : isSet(object.last_modified)
        ? globalThis.String(object.last_modified)
        : "",
      relatedTo: isSet(object.relatedTo)
        ? globalThis.String(object.relatedTo)
        : isSet(object.related_to)
        ? globalThis.String(object.related_to)
        : "",
    };
  },

  toJSON(message: VJournal): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.dtStart !== "") {
      obj.dtStart = message.dtStart;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.status !== 0) {
      obj.status = eventStatusToJSON(message.status);
    }
    if (message.classification !== 0) {
      obj.classification = accessClassificationToJSON(message.classification);
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.organizer !== undefined) {
      obj.organizer = Organizer.toJSON(message.organizer);
    }
    if (message.attendees?.length) {
      obj.attendees = message.attendees.map((e) => Attendee.toJSON(e));
    }
    if (message.rrule !== undefined) {
      obj.rrule = RecurrenceRule.toJSON(message.rrule);
    }
    if (message.created !== "") {
      obj.created = message.created;
    }
    if (message.lastModified !== "") {
      obj.lastModified = message.lastModified;
    }
    if (message.relatedTo !== "") {
      obj.relatedTo = message.relatedTo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VJournal>, I>>(base?: I): VJournal {
    return VJournal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VJournal>, I>>(object: I): VJournal {
    const message = createBaseVJournal();
    message.uid = object.uid ?? "";
    message.sequence = object.sequence ?? 0;
    message.dtStart = object.dtStart ?? "";
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.status = object.status ?? 0;
    message.classification = object.classification ?? 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.organizer = (object.organizer !== undefined && object.organizer !== null)
      ? Organizer.fromPartial(object.organizer)
      : undefined;
    message.attendees = object.attendees?.map((e) => Attendee.fromPartial(e)) || [];
    message.rrule = (object.rrule !== undefined && object.rrule !== null)
      ? RecurrenceRule.fromPartial(object.rrule)
      : undefined;
    message.created = object.created ?? "";
    message.lastModified = object.lastModified ?? "";
    message.relatedTo = object.relatedTo ?? "";
    return message;
  },
};

function createBaseVCalendar(): VCalendar {
  return {
    prodId: "",
    version: "",
    calScale: "",
    method: "",
    name: "",
    description: "",
    color: "",
    source: "",
    refreshInterval: "",
    events: [],
    todos: [],
    journals: [],
  };
}

export const VCalendar: MessageFns<VCalendar> = {
  fromJSON(object: any): VCalendar {
    return {
      prodId: isSet(object.prodId)
        ? globalThis.String(object.prodId)
        : isSet(object.prod_id)
        ? globalThis.String(object.prod_id)
        : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      calScale: isSet(object.calScale)
        ? globalThis.String(object.calScale)
        : isSet(object.cal_scale)
        ? globalThis.String(object.cal_scale)
        : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      refreshInterval: isSet(object.refreshInterval)
        ? globalThis.String(object.refreshInterval)
        : isSet(object.refresh_interval)
        ? globalThis.String(object.refresh_interval)
        : "",
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => VEvent.fromJSON(e))
        : [],
      todos: globalThis.Array.isArray(object?.todos)
        ? object.todos.map((e: any) => VTodo.fromJSON(e))
        : [],
      journals: globalThis.Array.isArray(object?.journals)
        ? object.journals.map((e: any) => VJournal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VCalendar): unknown {
    const obj: any = {};
    if (message.prodId !== "") {
      obj.prodId = message.prodId;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.calScale !== "") {
      obj.calScale = message.calScale;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.refreshInterval !== "") {
      obj.refreshInterval = message.refreshInterval;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => VEvent.toJSON(e));
    }
    if (message.todos?.length) {
      obj.todos = message.todos.map((e) => VTodo.toJSON(e));
    }
    if (message.journals?.length) {
      obj.journals = message.journals.map((e) => VJournal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VCalendar>, I>>(base?: I): VCalendar {
    return VCalendar.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VCalendar>, I>>(object: I): VCalendar {
    const message = createBaseVCalendar();
    message.prodId = object.prodId ?? "";
    message.version = object.version ?? "";
    message.calScale = object.calScale ?? "";
    message.method = object.method ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.color = object.color ?? "";
    message.source = object.source ?? "";
    message.refreshInterval = object.refreshInterval ?? "";
    message.events = object.events?.map((e) => VEvent.fromPartial(e)) || [];
    message.todos = object.todos?.map((e) => VTodo.fromPartial(e)) || [];
    message.journals = object.journals?.map((e) => VJournal.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
