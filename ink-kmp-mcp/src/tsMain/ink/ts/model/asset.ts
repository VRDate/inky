// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               v5.28.3
// source: ink/model/asset.proto

/* eslint-disable */

export const protobufPackage = "ink.model";

export interface AssetCategory {
  /** "üó°Ô∏è" */
  emoji: string;
  /** "sword" */
  name: string;
  /** weapon, armor, character, consumable, quest, currency */
  type: string;
  /** "sword_1h", "staff_2h", "cast" */
  animSet: string;
  /** main_hand, off_hand, two_hand, none */
  gripType: string;
  /** "weapon_sword", "char_wizard" */
  meshPrefix: string;
  /** "sfx_metal", "sfx_wood", "voice" */
  audioCategory: string;
  /** Unicode metadata (from UnicodeDataLoader) */
  unicodeGroup: string;
  /** "food-prepared", "sport" */
  unicodeSubgroup: string;
  /** UTF-32 codepoints [0x1F5E1] */
  codePoints: number[];
  /** "7.0" */
  unicodeVersion: string;
  /** "So" (Symbol, other) */
  generalCategory: string;
  /** true if maps to 3D asset pipeline */
  isGameAsset: boolean;
}

export interface VoiceRef {
  /** "gandalf" */
  characterId: string;
  /** "en", "he", "ar" */
  language: string;
  /** "voices/gandalf_en.flac" */
  flacPath: string;
}

export interface AssetRef {
  emoji: string;
  category:
    | AssetCategory
    | undefined;
  /** "weapon_sword_01.glb" */
  meshPath: string;
  /** "sword_1h" */
  animSetId: string;
  voiceRef: VoiceRef | undefined;
  metadata: { [key: string]: string };
}

export interface AssetRef_MetadataEntry {
  key: string;
  value: string;
}

function createBaseAssetCategory(): AssetCategory {
  return {
    emoji: "",
    name: "",
    type: "",
    animSet: "",
    gripType: "",
    meshPrefix: "",
    audioCategory: "",
    unicodeGroup: "",
    unicodeSubgroup: "",
    codePoints: [],
    unicodeVersion: "",
    generalCategory: "",
    isGameAsset: false,
  };
}

export const AssetCategory: MessageFns<AssetCategory> = {
  fromJSON(object: any): AssetCategory {
    return {
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      animSet: isSet(object.animSet)
        ? globalThis.String(object.animSet)
        : isSet(object.anim_set)
        ? globalThis.String(object.anim_set)
        : "",
      gripType: isSet(object.gripType)
        ? globalThis.String(object.gripType)
        : isSet(object.grip_type)
        ? globalThis.String(object.grip_type)
        : "",
      meshPrefix: isSet(object.meshPrefix)
        ? globalThis.String(object.meshPrefix)
        : isSet(object.mesh_prefix)
        ? globalThis.String(object.mesh_prefix)
        : "",
      audioCategory: isSet(object.audioCategory)
        ? globalThis.String(object.audioCategory)
        : isSet(object.audio_category)
        ? globalThis.String(object.audio_category)
        : "",
      unicodeGroup: isSet(object.unicodeGroup)
        ? globalThis.String(object.unicodeGroup)
        : isSet(object.unicode_group)
        ? globalThis.String(object.unicode_group)
        : "",
      unicodeSubgroup: isSet(object.unicodeSubgroup)
        ? globalThis.String(object.unicodeSubgroup)
        : isSet(object.unicode_subgroup)
        ? globalThis.String(object.unicode_subgroup)
        : "",
      codePoints: globalThis.Array.isArray(object?.codePoints)
        ? object.codePoints.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.code_points)
        ? object.code_points.map((e: any) => globalThis.Number(e))
        : [],
      unicodeVersion: isSet(object.unicodeVersion)
        ? globalThis.String(object.unicodeVersion)
        : isSet(object.unicode_version)
        ? globalThis.String(object.unicode_version)
        : "",
      generalCategory: isSet(object.generalCategory)
        ? globalThis.String(object.generalCategory)
        : isSet(object.general_category)
        ? globalThis.String(object.general_category)
        : "",
      isGameAsset: isSet(object.isGameAsset)
        ? globalThis.Boolean(object.isGameAsset)
        : isSet(object.is_game_asset)
        ? globalThis.Boolean(object.is_game_asset)
        : false,
    };
  },

  toJSON(message: AssetCategory): unknown {
    const obj: any = {};
    if (message.emoji !== "") {
      obj.emoji = message.emoji;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.animSet !== "") {
      obj.animSet = message.animSet;
    }
    if (message.gripType !== "") {
      obj.gripType = message.gripType;
    }
    if (message.meshPrefix !== "") {
      obj.meshPrefix = message.meshPrefix;
    }
    if (message.audioCategory !== "") {
      obj.audioCategory = message.audioCategory;
    }
    if (message.unicodeGroup !== "") {
      obj.unicodeGroup = message.unicodeGroup;
    }
    if (message.unicodeSubgroup !== "") {
      obj.unicodeSubgroup = message.unicodeSubgroup;
    }
    if (message.codePoints?.length) {
      obj.codePoints = message.codePoints.map((e) => Math.round(e));
    }
    if (message.unicodeVersion !== "") {
      obj.unicodeVersion = message.unicodeVersion;
    }
    if (message.generalCategory !== "") {
      obj.generalCategory = message.generalCategory;
    }
    if (message.isGameAsset !== false) {
      obj.isGameAsset = message.isGameAsset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetCategory>, I>>(base?: I): AssetCategory {
    return AssetCategory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetCategory>, I>>(object: I): AssetCategory {
    const message = createBaseAssetCategory();
    message.emoji = object.emoji ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.animSet = object.animSet ?? "";
    message.gripType = object.gripType ?? "";
    message.meshPrefix = object.meshPrefix ?? "";
    message.audioCategory = object.audioCategory ?? "";
    message.unicodeGroup = object.unicodeGroup ?? "";
    message.unicodeSubgroup = object.unicodeSubgroup ?? "";
    message.codePoints = object.codePoints?.map((e) => e) || [];
    message.unicodeVersion = object.unicodeVersion ?? "";
    message.generalCategory = object.generalCategory ?? "";
    message.isGameAsset = object.isGameAsset ?? false;
    return message;
  },
};

function createBaseVoiceRef(): VoiceRef {
  return { characterId: "", language: "", flacPath: "" };
}

export const VoiceRef: MessageFns<VoiceRef> = {
  fromJSON(object: any): VoiceRef {
    return {
      characterId: isSet(object.characterId)
        ? globalThis.String(object.characterId)
        : isSet(object.character_id)
        ? globalThis.String(object.character_id)
        : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      flacPath: isSet(object.flacPath)
        ? globalThis.String(object.flacPath)
        : isSet(object.flac_path)
        ? globalThis.String(object.flac_path)
        : "",
    };
  },

  toJSON(message: VoiceRef): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.flacPath !== "") {
      obj.flacPath = message.flacPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceRef>, I>>(base?: I): VoiceRef {
    return VoiceRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceRef>, I>>(object: I): VoiceRef {
    const message = createBaseVoiceRef();
    message.characterId = object.characterId ?? "";
    message.language = object.language ?? "";
    message.flacPath = object.flacPath ?? "";
    return message;
  },
};

function createBaseAssetRef(): AssetRef {
  return { emoji: "", category: undefined, meshPath: "", animSetId: "", voiceRef: undefined, metadata: {} };
}

export const AssetRef: MessageFns<AssetRef> = {
  fromJSON(object: any): AssetRef {
    return {
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : "",
      category: isSet(object.category) ? AssetCategory.fromJSON(object.category) : undefined,
      meshPath: isSet(object.meshPath)
        ? globalThis.String(object.meshPath)
        : isSet(object.mesh_path)
        ? globalThis.String(object.mesh_path)
        : "",
      animSetId: isSet(object.animSetId)
        ? globalThis.String(object.animSetId)
        : isSet(object.anim_set_id)
        ? globalThis.String(object.anim_set_id)
        : "",
      voiceRef: isSet(object.voiceRef)
        ? VoiceRef.fromJSON(object.voiceRef)
        : isSet(object.voice_ref)
        ? VoiceRef.fromJSON(object.voice_ref)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: AssetRef): unknown {
    const obj: any = {};
    if (message.emoji !== "") {
      obj.emoji = message.emoji;
    }
    if (message.category !== undefined) {
      obj.category = AssetCategory.toJSON(message.category);
    }
    if (message.meshPath !== "") {
      obj.meshPath = message.meshPath;
    }
    if (message.animSetId !== "") {
      obj.animSetId = message.animSetId;
    }
    if (message.voiceRef !== undefined) {
      obj.voiceRef = VoiceRef.toJSON(message.voiceRef);
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetRef>, I>>(base?: I): AssetRef {
    return AssetRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetRef>, I>>(object: I): AssetRef {
    const message = createBaseAssetRef();
    message.emoji = object.emoji ?? "";
    message.category = (object.category !== undefined && object.category !== null)
      ? AssetCategory.fromPartial(object.category)
      : undefined;
    message.meshPath = object.meshPath ?? "";
    message.animSetId = object.animSetId ?? "";
    message.voiceRef = (object.voiceRef !== undefined && object.voiceRef !== null)
      ? VoiceRef.fromPartial(object.voiceRef)
      : undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAssetRef_MetadataEntry(): AssetRef_MetadataEntry {
  return { key: "", value: "" };
}

export const AssetRef_MetadataEntry: MessageFns<AssetRef_MetadataEntry> = {
  fromJSON(object: any): AssetRef_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AssetRef_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetRef_MetadataEntry>, I>>(base?: I): AssetRef_MetadataEntry {
    return AssetRef_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetRef_MetadataEntry>, I>>(object: I): AssetRef_MetadataEntry {
    const message = createBaseAssetRef_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
