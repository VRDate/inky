@startuml ink.kt – Kotlin Ink Runtime Class Diagram

' ==============================================================================
' ink.kt — Kotlin Multiplatform Ink Runtime
' Package: ink.kt
' Source:  ink-kmp-mcp/src/commonMain/kotlin/ink/kt/
'
' Comprehensive class diagram generated from all 36 .kt source files.
' ==============================================================================

' ── Skin params ──────────────────────────────────────────────────────────────

skinparam backgroundColor #FAFAFA
skinparam shadowing false
skinparam roundcorner 8

skinparam class {
    BackgroundColor #E3F2FD
    BorderColor #1565C0
    HeaderBackgroundColor #1976D2
    FontColor #212121
    FontName JetBrains Mono
    FontSize 11
    HeaderFontColor #FFFFFF
    HeaderFontSize 12
    AttributeFontSize 10
    StereotypeFontSize 9
}

skinparam interface {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
    HeaderBackgroundColor #388E3C
    FontColor #212121
    HeaderFontColor #FFFFFF
    FontSize 11
}

skinparam enum {
    BackgroundColor #FFF3E0
    BorderColor #E65100
    HeaderBackgroundColor #F57C00
    FontColor #212121
    HeaderFontColor #FFFFFF
    FontSize 11
}

skinparam object {
    BackgroundColor #F3E5F5
    BorderColor #6A1B9A
    HeaderBackgroundColor #7B1FA2
    FontColor #212121
    HeaderFontColor #FFFFFF
    FontSize 11
}

skinparam note {
    BackgroundColor #FFFDE7
    BorderColor #F9A825
    FontSize 10
    FontName JetBrains Mono
}

skinparam package {
    BackgroundColor #ECEFF1
    BorderColor #546E7A
    FontSize 13
    FontColor #37474F
    FontStyle bold
}

' ── Three-Way Comparison Notes ───────────────────────────────────────────────

note as N_OVERVIEW
  **ink.kt — Kotlin Multiplatform Ink Runtime**
  **Three-way comparison: Kotlin (ink.kt) vs C# (Ink.Runtime) vs Java (blade-ink)**

  **Package naming:**
    Kotlin:  ""ink.kt""
    C#:      ""Ink.Runtime""
    Java:    ""com.bladecoder.ink.runtime""

  **Key consolidations in Kotlin port:**
    Value.kt combines 8 separate Java files (BoolValue, IntValue, FloatValue,
    StringValue, DivertTargetValue, VariablePointerValue, ListValue + abstract Value)
    into a single sealed class hierarchy.

  **Class naming differences:**
    Kotlin ""InkObject"" = Java ""RTObject"" = C# ""Object""
    Kotlin ""InkFlow"" = Java/C#/JS ""Flow"" (avoids kotlinx.coroutines clash)
    Kotlin ""InkVoid"" = Java/C#/JS ""Void"" (avoids java.lang.Void clash)
    Kotlin ""CallStack.InkThread"" = Java/C#/JS ""Thread"" (avoids java.lang.Thread clash)
    Kotlin ""StoryException"" = Java ""StoryException"" = C# ""StoryException""
    Kotlin ""ErrorHandler"" (fun interface) = Java ""ErrorHandler"" (interface) = C# delegate

  **Kotlin-specific features used throughout:**
    sealed class (Value hierarchy), data class (Pointer, InkListItem, DateComponents),
    fun interface (SAM: BinaryOp, UnaryOp, ErrorHandler, VariableChanged, ExternalFunction,
    VariableObserver, InnerWriter, OnDidLoadState), object singleton (SimpleJson,
    JsonSerialisation, InkClock, Json), enum class (ValueType, PushPopType, ErrorType,
    CommandType, OutputOp), when expressions (type dispatch), buildString,
    operator overloading (+/- on InkList, get/set on VariablesState),
    LinkedHashMap/LinkedHashSet (insertion-order + O(1) everywhere),
    kotlin.time.TimeSource.Monotonic (Stopwatch), kotlinx.datetime.Clock.System (InkClock),
    by delegation (InkList : MutableMap by _map), lazy properties (ListDefinition.items)
end note

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 1: CORE
' ══════════════════════════════════════════════════════════════════════════════

package "1. Core" #E3F2FD {

    class InkObject <<open>> {
        + parent : Container?
        + {open} id : String                         ' L:20
        + {open} text : String                       ' L:21
        + lineNumber : Int                           ' L:22
        ~ count : Int                                ' L:23
        - _debugMetadata : DebugMetadata?            ' L:25
        - _path : Path?                              ' L:26
        --
        + ownDebugMetadata : DebugMetadata? <<get/set>>  ' L:28-30
        + debugMetadata : DebugMetadata? <<get>>         ' L:32-33
        + path : Path <<get>>                            ' L:43-66
        + rootContentContainer : Container? <<get>>      ' L:123-130
        --
        + debugLineNumberOfPath(path: Path?) : Int?      ' L:35-41
        + resolvePath(path: Path) : SearchResult         ' L:68-79
        + convertPathToRelative(globalPath: Path) : Path ' L:81-105
        + compactPathString(otherPath: Path) : String    ' L:107-121
        + {open} copy() : InkObject                      ' L:132-134
        + getText(story: VariableMap) : String            ' L:137-138
    }

    note right of InkObject
      **ink.kt** : InkObject.kt:1-139
        parent                     L:17
        id/text/lineNumber/count   L:20-23 (mica Content)
        resolvePath()              L:68
        copy()                     L:132
        getText()                  L:137 (mica)
      ----
      **C#** : Object.cs:1-251
        parent                     L:17
        ResolvePath()              L:106
        Copy()                     L:201
        SetChild<T>()              L:206 (NOT in KT)
      ----
      **Java** : RTObject.java:1-183
        getParent()/setParent()    L:28-34
        resolvePath()              L:105
        copy()                     L:180
      ----
      **JS** : InkObject (inkjs)
      **mica** : see ink.kt.mica.puml Content
      **Status**: COMPLETE + MICA_MERGED
    end note

    class Container {
        - _name : String?
        + content : MutableList<InkObject>
        + namedContent : HashMap<String, INamedContent>
        + visitsShouldBeCounted : Boolean
        + turnIndexShouldBeCounted : Boolean
        + countingAtStartOnly : Boolean
        + namedOnlyContent : HashMap<String, InkObject> <<get>>
        + countFlags : Int <<get/set>>
        + hasValidName : Boolean <<get>>
        --
        + addContent(contentObj: InkObject)
        + addContents(contentList: List<InkObject>)
        + insertContent(contentObj: InkObject, index: Int)
        + addToNamedContentOnly(namedContentObj: INamedContent)
        + addContentsOfContainer(otherContainer: Container)
        + contentAtPath(path: Path, ...) : SearchResult
        + contentWithPathComponent(component: Path.Component) : InkObject?
        + setName(value: String?)
        + setNamedOnlyContent(value: HashMap<String, InkObject>)
        + buildStringOfHierarchy() : String
        .. companion ..
        {static} COUNTFLAGS_VISITS : Int = 1
        {static} COUNTFLAGS_TURNS : Int = 2
        {static} COUNTFLAGS_COUNTSTARTONLY : Int = 4
    }

    note right of Container
      **ink.kt** : Container.kt:1-269
        content                   L:19
        namedContent              L:20
        index/children/size       L:23-25 (mica)
        add()/get()/indexOf()     L:27-29 (mica)
        contentAtPath()           L:144-182
        buildStringOfHierarchy()  L:252-256
      ----
      **C#** : Container.cs:1-376
        content                   L:14-21
        ContentAtPath()           L:229-274
      **Java** : Container.java:1-351
        content                   L:12
        contentAtPath()           L:218-264
      ----
      **mica** : see ink.kt.mica.puml Container
      **Status**: COMPLETE + MICA_MERGED
    end note

    class Path {
        - _components : MutableList<Component>       ' L:17
        + isRelative : Boolean <<get>>               ' L:18
        - _componentsString : String?                ' L:20
        + head : Component? <<get>>                  ' L:40-41
        + tail : Path <<get>>                        ' L:43-45
        + length : Int <<get>>                       ' L:47-48
        + lastComponent : Component? <<get>>         ' L:50-51
        + componentsString : String <<get>>          ' L:79-97
        --
        + Path()                                     ' L:22
        + Path(head: Component, tail: Path)          ' L:24
        + Path(components: Collection<Component>, relative: Boolean) ' L:29
        + Path(componentsString: String)             ' L:34
        + getComponent(index: Int) : Component       ' L:38
        + containsNamedComponent() : Boolean         ' L:53-54
        + pathByAppendingPath(pathToAppend: Path) : Path  ' L:56-70
        + pathByAppendingComponent(c: Component) : Path   ' L:72-77
        - setComponentsString(value: String)         ' L:99-119
        + toString() : String                        ' L:121
        + equals(other: Any?) : Boolean              ' L:123-128
        + hashCode() : Int                           ' L:130
        .. companion ..
        {static} PARENT_ID : String = "^"            ' L:133
        {static} self : Path <<get>>                 ' L:135-136
    }

    note right of Path
      **ink.kt** : Path.kt:1-175
        _components               L:17
        isRelative                L:18 (private set)
        4 constructors            L:22,24,29,34
        pathByAppendingPath()     L:56
        componentsString          L:79 (lazy + buildString)
        setComponentsString()     L:99 (split("."))
        equals()                  L:123 (indices.all)
      ----
      **C#** : Path.cs:1-276
        Component is nested struct
        _components               L:21
        PathByAppendingPath()     L:84-105
        componentsString          L:111-164
      **Java** : Path.java:1-232
        Component is inner class  L:10-94
        _components               L:100
        setComponentsString()     L:153-185
        equals()                  L:187-198
      ----
      Kotlin: buildString + .any{} + .all{}
      vs Java StringBuilder + for-loop.
      **Status**: COMPLETE
    end note

    class "Path.Component" as PathComponent {
        + index : Int                                ' L:143
        + name : String?                             ' L:144
        + isIndex : Boolean <<get>>                  ' L:156
        + isParent : Boolean <<get>>                 ' L:157
        --
        + Component(index: Int)                      ' L:146
        + Component(name: String)                    ' L:151
        + toString() : String                        ' L:159-160
        + equals(other: Any?) : Boolean              ' L:162-166
        + hashCode() : Int                           ' L:168-169
        .. companion ..
        {static} toParent() : Component              ' L:172
    }

    class SearchResult {
        + obj : InkObject?                           ' L:14
        + approximate : Boolean                      ' L:15
        + correctObj : InkObject? <<get>>            ' L:19-20
        + container : Container? <<get>>             ' L:22-23
        --
        + SearchResult(obj?, approximate)            ' L:13
        + SearchResult(sr: SearchResult)             ' L:17
    }

    note right of SearchResult
      **ink.kt** : SearchResult.kt:1-24
        correctObj               L:19 (if !approximate)
        container (as? cast)     L:22
      ----
      **C#** : SearchResult.cs:1-32
        struct (value type)
        correctObj               L:12
        container                L:17
      **Java** : SearchResult.java:1-39
        class (mutable fields)
        correctObj               L:22
        container                L:27
      ----
      Kotlin: mutable class (same as Java).
      C# version is a value-type struct.
      **Status**: COMPLETE
    end note

    class Pointer <<data class>> {
        + container : Container?                     ' L:16
        + index : Int                                ' L:17
        + isNull : Boolean <<get>>                   ' L:34
        + path : Path? <<get>>                       ' L:36-43
        --
        + Pointer(container?, index)                 ' L:15
        + Pointer(p: Pointer)                        ' L:19
        + assign(p: Pointer)                         ' L:21-24
        + resolve() : InkObject?                     ' L:26-32
        + toString() : String                        ' L:45-47
        .. companion ..
        {static} Null : Pointer                      ' L:50
        {static} startOf(container: Container) : Pointer ' L:52
    }

    note right of Pointer
      **ink.kt** : Pointer.kt:1-54
        data class — auto equals/copy/destructuring
        resolve()                L:26 (returns InkObject?)
        Null sentinel            L:50
        startOf()                L:52
      ----
      **C#** : Pointer.cs:1-87
        struct (value type)
        Resolve()                L:32
        Null (static readonly)   L:80
        StartOf()                L:85
      **Java** : Pointer.java:1-92
        class (reference type, mutable)
        resolve()                L:29
        Null (static field)      L:85
        StartOf()                L:88
      ----
      Kotlin data class gives value semantics
      like C# struct, with copy()/destructuring.
      **Status**: COMPLETE
    end note

    class DebugMetadata {
        + startLineNumber : Int                      ' L:17
        + endLineNumber : Int                        ' L:18
        + startCharacterNumber : Int                 ' L:19
        + endCharacterNumber : Int                   ' L:20
        + fileName : String?                         ' L:21
        + sourceName : String?                       ' L:22
        --
        + merge(dm: DebugMetadata) : DebugMetadata   ' L:28-64
        + toString() : String                        ' L:66-68
    }

    note right of DebugMetadata
      **ink.kt** : DebugMetadata.kt:1-69
        merge() uses when expr   L:33,48
        toString()               L:66
      ----
      **C#** : DebugMetadata.cs:1-73
        Merge()                  L:19
        ToString()               L:60
      **Java** : DebugMetadata.java:1-84
        merge() uses if-chains   L:15
        toString()               L:68
      ----
      Kotlin: when expr for merge() ranges
      vs if-chains in Java/C#.
      **Status**: COMPLETE
    end note
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 2: CONTENT
' ══════════════════════════════════════════════════════════════════════════════

package "2. Content" #E3F2FD {

    class ChoicePoint {
        - _pathOnChoice : Path?                     ' L:15
        + onceOnly : Boolean                        ' L:14
        + hasCondition : Boolean                    ' L:17
        + hasStartContent : Boolean                 ' L:18
        + hasChoiceOnlyContent : Boolean            ' L:19
        + isInvisibleDefault : Boolean              ' L:20
        + choiceTarget : Container <<get>>          ' L:22
        + pathOnChoice : Path? <<get/set>>          ' L:25-35
        + pathStringOnChoice : String? <<get/set>>  ' L:37-39
        + flags : Int <<get/set>>                   ' L:41-57 (bitmask)
        --
        + ChoicePoint(onceOnly: Boolean = true)     ' L:14
        + toString() : String                       ' L:59
    }

    note right of ChoicePoint
      **ink.kt** : ChoicePoint.kt:1-62
        _pathOnChoice             L:15
        flags (bitmask)           L:41-57
        toString()                L:59
      ----
      **C#** : ChoicePoint.cs:1-90
        _pathOnChoice             L:27
        flags                     L:50-67
        ToString()                L:76-86
      ----
      **Java** : ChoicePoint.java:1-136
        getFlags()/setFlags()     L:33-89
        toString()                L:120-134
      ----
      **Status**: COMPLETE
    end note

    class Choice <<Comparable>> {
        + text : String                             ' L:17 (override var)
        + targetPath : Path?                        ' L:18
        + sourcePath : String?                      ' L:19
        + isInvisibleDefault : Boolean              ' L:20
        + originalThreadIndex : Int                 ' L:21
        + tags : List<String>?                      ' L:22
        + level : Int                               ' L:25 (parser)
        ~ conditions : MutableList<String>          ' L:26 (parser)
        ~ repeatable : Boolean                      ' L:27 (parser)
        + threadAtGeneration : CallStack.Thread?    ' L:31
        + pathStringOnChoice : String? <<get/set>>  ' L:33-35
        --
        + Choice()                                  ' L:15
        ~ Choice(textBase, level, parent, lineNum)  ' L:39 (parser)
        + isFallBack() : Boolean                    ' L:87 (parser)
        + evaluateConditions(story: VariableMap) : Boolean  ' L:89 (parser)
        + compareTo(other: Choice) : Int            ' L:107
        + equals(other: Any?) : Boolean             ' L:110
        + hashCode() : Int                          ' L:116
        + clone() : Choice                          ' L:118
        .. companion ..
        {static} getChoiceDepth(line: String) : Int           ' L:133 (parser)
        {static} getId(header, parent) : String               ' L:144 (parser)
        {static} extractChoiceText(header) : String           ' L:159 (parser)
        {static} getParent(container, lvl) : Container        ' L:176 (parser)
    }

    note right of Choice
      **ink.kt** : Choice.kt:1-187
        text                      L:17
        targetPath                L:18
        level/conditions/repeatable L:25-27 (parser)
        threadAtGeneration        L:31
        clone()                   L:118
        compareTo()               L:107 (Kotlin-only)
      ----
      **C#** : Choice.cs:1-69
        text                      L:15
        pathStringOnChoice        L:21-28
        targetPath                L:42
        Clone()                   L:55-65
      ----
      **Java** : Choice.java:1-87
        targetPath                L:11
        getText()                 L:51
        clone()                   L:76
      ----
      **mica** : see ink.kt.mica.puml Choice
      **Status**: COMPLETE + MICA_MERGED
    end note

    class Divert {
        - _targetPath : Path?                       ' L:16
        - _targetPointer : Pointer                  ' L:17
        + stackPushType : PushPopType               ' L:15
        + pushesToStack : Boolean                   ' L:19
        + isExternal : Boolean                      ' L:20
        + externalArgs : Int                        ' L:21
        + isConditional : Boolean                   ' L:22
        + variableDivertName : String?              ' L:23
        + hasVariableTarget : Boolean <<get>>       ' L:43
        + targetPath : Path? <<get/set>>            ' L:46-59
        + targetPointer : Pointer <<get>>           ' L:61-73
        + targetPathString : String? <<get/set>>    ' L:75-80
        --
        + Divert(stackPushType: PushPopType = Function) ' L:15
        ~ Divert(lineNumber, text, parent)          ' L:27 (parser)
        + resolveDivert(story: Story) : Container   ' L:35 (parser)
        + equals(other: Any?) : Boolean             ' L:100
        + hashCode() : Int                          ' L:107
        + toString() : String                       ' L:82
    }

    note right of Divert
      **ink.kt** : Divert.kt:1-111
        _targetPath               L:16
        targetPointer             L:61
        resolveDivert()           L:35 (parser)
        toString() uses buildString
      ----
      **C#** : Divert.cs:1-150
        targetPath                L:7-22
        Equals()                  L:81-94
        GetHashCode()             L:96-105
        ToString()                L:107-146
      ----
      **Java** : Divert.java:1-205
        getTargetPointer()        L:60-72
        hashCode()                L:98-112
        toString()                L:164-203
      ----
      **mica** : see ink.kt.mica.puml Divert
      **Status**: COMPLETE + MICA_MERGED
    end note

    class Glue {
        + toString() : String                       ' L:14
    }

    note right of Glue
      **ink.kt** : Glue.kt:1-15
      **C#** : Glue.cs:1-13
      **Java** : Glue.java:1-10
      All identical marker class.
      **Status**: COMPLETE
    end note

    class Tag {
        + text : String                             ' L:13 (override var)
        --
        + Tag(text: String)                         ' L:13
        ~ Tag(content, parent, lineNumber)          ' L:16 (parser)
        + toString() : String                       ' L:22
    }

    note right of Tag
      **ink.kt** : Tag.kt:1-23
        Tag(text)                 L:13
        Tag(content,parent,ln)    L:16 (parser)
      ----
      **C#** : Tag.cs:1-27
        Tag(string)               L:16-19
      **Java** : Tag.java:1-17
        Tag(String)               L:10-12
      ----
      **mica** : see ink.kt.mica.puml Tag
      **Status**: COMPLETE + MICA_MERGED
    end note

    class InkVoid

    note right of InkVoid
      **ink.kt** : InkVoid.kt:1-13 (renamed from Void)
      **C#** : Void.cs:1-10
      **Java** : Void.java:1-5
      **JS** : Void.ts
      Renamed to InkVoid to avoid java.lang.Void clash.
      All identical empty marker class.
      **Status**: COMPLETE
    end note

    class ControlCommand {
        + commandType : CommandType                 ' L:15
        --
        + ControlCommand(commandType: CommandType = NotSet) ' L:15
        + copy() : InkObject                        ' L:47
        + toString() : String                       ' L:49
    }

    note right of ControlCommand
      **ink.kt** : ControlCommand.kt:1-50
        CommandType enum          L:17-45
        copy()                    L:47
      ----
      **C#** : ControlCommand.cs:1-183
        26 static factory methods L:64-171
        (EvalStart(), etc. — NOT in KT/Java)
      **Java** : ControlCommand.java:1-62
        CommandType enum          L:4-32
      ----
      **Status**: COMPLETE
      (C# factories are convenience, not functional gap)
    end note

    enum "ControlCommand.CommandType" as CommandType {
        NotSet
        EvalStart
        EvalOutput
        EvalEnd
        Duplicate
        PopEvaluatedValue
        PopFunction
        PopTunnel
        BeginString
        EndString
        NoOp
        ChoiceCount
        Turns
        TurnsSince
        ReadCount
        Random
        SeedRandom
        VisitIndex
        SequenceShuffleIndex
        StartThread
        Done
        End
        ListFromInt
        ListRange
        ListRandom
        BeginTag
        EndTag
    }

    class VariableAssignment {
        + variableName : String?                    ' L:14
        + isNewDeclaration : Boolean                ' L:15
        + isGlobal : Boolean                        ' L:17
        --
        + VariableAssignment(variableName?, isNewDeclaration?) ' L:13
        + toString() : String                       ' L:19
    }

    note right of VariableAssignment
      **ink.kt** : VariableAssignment.kt:1-21
      **C#** : VariableAssignment.cs:1-27
      **Java** : VariableAssignment.java:1-49
      All structurally identical.
      **Status**: COMPLETE
    end note

    class VariableReference {
        + name : String?                            ' L:13
        + pathForCount : Path?                      ' L:15
        + containerForCount : Container? <<get>>    ' L:17
        + pathStringForCount : String? <<get/set>>  ' L:20-25
        --
        + VariableReference(name: String? = null)   ' L:13
        + toString() : String                       ' L:27
    }

    note right of VariableReference
      **ink.kt** : VariableReference.kt:1-32
      **C#** : VariableReference.cs:1-52
      **Java** : VariableReference.java:1-62
      All structurally identical.
      **Status**: COMPLETE
    end note

    class NativeFunctionCall {
        + name : String? <<get/set>>
        + numberOfParameters : Int <<get>>
        - _isPrototype : Boolean
        - _operationFuncs : LinkedHashMap<ValueType, Any>?
        - _prototype : NativeFunctionCall?
        --
        + NativeFunctionCall()
        + NativeFunctionCall(name: String)
        + call(parameters: List<InkObject>) : InkObject?
        + toString() : String
        .. companion ..
        {static} Add, Subtract, Multiply, ... : String
        {static} callExistsWithName(name: String) : Boolean
        {static} callWithName(name: String) : NativeFunctionCall
    }

    interface "NativeFunctionCall.BinaryOp" as BinaryOp <<fun interface>> {
        + invoke(left: Any?, right: Any?) : Any?
    }

    interface "NativeFunctionCall.UnaryOp" as UnaryOp <<fun interface>> {
        + invoke(value: Any?) : Any?
    }

    note bottom of NativeFunctionCall
      **Kotlin:** ""fun interface"" (SAM) for BinaryOp/UnaryOp
      — lambdas auto-convert. LinkedHashMap registry.
      **C#:** typed delegates ""BinaryOp<T>""/""UnaryOp<T>""
      **Java:** interfaces with ""Object"" — verbose anonymous classes
      **JS:** plain function callbacks
    end note
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 3: VALUES
' ══════════════════════════════════════════════════════════════════════════════

package "3. Values" #E3F2FD {

    abstract class "Value<T>" as Value <<sealed>> {
        + value : T
        + valueType : ValueType <<abstract get>>
        + isTruthy : Boolean <<abstract get>>
        + valueObject : Any? <<get>>
        --
        + cast(newType: ValueType) : Value<*>? <<abstract>>
        + copy() : InkObject
        + toString() : String
        # badCastException(targetType: ValueType) : StoryException
        .. companion ..
        {static} create(obj: Any?) : Value<*>?
    }

    note right of Value
      **ink.kt** : Value.kt:25-57
        value : T                 L:25
        cast()                    L:29 (abstract)
        create()                  L:45-55 (companion)
        badCastException()        L:37
      ----
      **C#** : Value.cs:28-96
        2-class hierarchy: Value + Value<T>
        Create()                  L:37-64
      **Java** : AbstractValue + Value<T>
        2-class hierarchy: AbstractValue.java + Value.java
        create()                  L:12-38
      ----
      Kotlin sealed class collapses both into one.
      8 Java files -> 1 Value.kt (sealed).
      **Status**: COMPLETE
    end note

    class BoolValue {
        + valueType : ValueType <<get>> = Bool
        + isTruthy : Boolean <<get>>
        --
        + BoolValue(value: Boolean = false)
        + cast(newType: ValueType) : Value<*>?
        + toString() : String
    }

    class IntValue {
        + valueType : ValueType <<get>> = Int
        + isTruthy : Boolean <<get>>
        --
        + IntValue(value: Int = 0)
        + cast(newType: ValueType) : Value<*>?
    }

    class FloatValue {
        + valueType : ValueType <<get>> = Float
        + isTruthy : Boolean <<get>>
        --
        + FloatValue(value: Float = 0.0f)
        + cast(newType: ValueType) : Value<*>?
    }

    class StringValue {
        + isNewline : Boolean
        + isInlineWhitespace : Boolean
        + isNonWhitespace : Boolean <<get>>
        + valueType : ValueType <<get>> = String
        + isTruthy : Boolean <<get>>
        --
        + StringValue(value: String = "")
        + cast(newType: ValueType) : Value<*>?
    }

    note right of StringValue
      **ink.kt** : Value.kt:116-131
        isNewline (val)           L:118
        isInlineWhitespace (val)  L:119
        cast() toIntOrNull/toFloatOrNull
      ----
      **C#** : Value.cs:203-258
        TryParse, InvariantCulture
      **Java** : StringValue.java:3-84
        try/catch parseInt/parseFloat
        has mutable setIsNewline/setIsInlineWhitespace (GAP)
      ----
      **Status**: COMPLETE
      (Java mutable whitespace setters noted)
    end note

    class DivertTargetValue {
        + targetPath : Path? <<get/set>>
        + valueType : ValueType <<get>> = DivertTarget
        + isTruthy : Boolean <<get>> // throws
        --
        + DivertTargetValue(targetPath: Path? = null)
        + cast(newType: ValueType) : Value<*>?
    }

    class VariablePointerValue {
        + variableName : String? <<get/set>>
        + contextIndex : Int
        + valueType : ValueType <<get>> = VariablePointer
        + isTruthy : Boolean <<get>> // throws
        --
        + VariablePointerValue(variableName?, contextIndex)
        + cast(newType: ValueType) : Value<*>?
        + copy() : InkObject
    }

    class ListValue {
        + valueType : ValueType <<get>> = List
        + isTruthy : Boolean <<get>>
        --
        + ListValue(list: InkList)
        + ListValue()
        + ListValue(singleItem: InkListItem, singleValue: Int)
        + cast(newType: ValueType) : Value<*>?
        .. companion ..
        {static} retainListOriginsForAssignment(oldValue, newValue)
    }

    enum ValueType {
        Bool
        Int
        Float
        List
        String
        DivertTarget
        VariablePointer
    }

    note right of ValueType
      **ink.kt** : ValueType.kt:1-23
      **C#** : Value.cs:11-26
        Bool=-1 (explicit ordinal)
      **Java** : ValueType.java
        Same members, positional ordinals.
      Ordinal order is significant for coercion.
      **Status**: COMPLETE
    end note
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 4: LISTS
' ══════════════════════════════════════════════════════════════════════════════

package "4. Lists" #E3F2FD {

    class InkList <<MutableMap<InkListItem, Int> by _map>> {
        - _map : LinkedHashMap<InkListItem, Int>
        + origins : MutableList<ListDefinition>?
        - _originNames : MutableList<String>?
        + originOfMaxItem : ListDefinition? <<get>>
        + originNames : MutableList<String>? <<get>>
        + singleOriginListName : String? <<get>>
        + maxItem : Map.Entry<InkListItem, Int> <<get>>
        + minItem : Map.Entry<InkListItem, Int> <<get>>
        + orderedItems : List<Map.Entry<...>> <<get>>
        + singleItem : InkListItem? <<get>>
        + inverse : InkList <<get>>
        + all : InkList <<get>>
        --
        + InkList()
        + InkList(otherList: InkList)
        + InkList(singleElement: Map.Entry<...>)
        + InkList(singleOriginListName: String, originStory: Story)
        + union(otherList: InkList) : InkList
        + without(listToRemove: InkList) : InkList
        + intersect(otherList: InkList) : InkList
        + hasIntersection(otherList: InkList) : Boolean
        + containsList(otherList: InkList) : Boolean
        + containsItemNamed(itemName: String) : Boolean
        + contains(listItemName: String) : Boolean
        + greaterThan(otherList: InkList) : Boolean
        + greaterThanOrEquals(otherList: InkList) : Boolean
        + lessThan(otherList: InkList) : Boolean
        + lessThanOrEquals(otherList: InkList) : Boolean
        + maxAsList() : InkList
        + minAsList() : InkList
        + listWithSubRange(minBound: Any?, maxBound: Any?) : InkList
        + addItem(item: InkListItem)
        + addItem(itemName: String, storyObject: Story? = null)
        + setInitialOriginName(name: String)
        + setInitialOriginNames(names: List<String>?)
        + operator plus(other: InkList) : InkList
        + operator minus(other: InkList) : InkList
        + equals(other: Any?) : Boolean
        + hashCode() : Int
        .. companion ..
        {static} fromString(myListItem: String, originStory: Story) : InkList
    }

    note right of InkList
      **ink.kt** : InkList.kt:1-317
        _map (LinkedHashMap)      L:20
        union()                   L:104
        operator plus/minus       L:129-130
        singleOriginListName      L:63
        addItem(InkListItem)      L:244
        addItem(String, Story?)   L:264
        contains(String)          L:142
        InkList(String, Story)    L:35
      ----
      **C#** : InkList.cs:117-649
        Dictionary<InkListItem,int>
        Union()                   L:379
        AddItem(string,Story)     L:213
        Contains(string)          L:447
      **Java** : InkList.java:1-621
        HashMap<InkListItem,Integer>
        InkList(String,Story)     L:44
        getSingleOriginListName() L:343
      ----
      **Status**: COMPLETE
    end note

    class InkListItem <<data class>> {
        + originName : String?
        + itemName : String?
        + isNull : Boolean <<get>>
        + fullName : String <<get>>
        --
        + InkListItem(originName?, itemName?)
        + InkListItem(fullName: String)
        + hashCode() : Int
        .. companion ..
        {static} Null : InkListItem
    }

    note right of InkListItem
      **ink.kt** : InkListItem.kt:1-45
        data class — equals/copy/destructuring free
        Null sentinel              L:43
        hashCode()                 L:36-40
      ----
      **C#** : InkList.cs:11-108
        struct (value type, readonly)
        Null property              L:43-47
      **Java** : InkListItem.java:1-96
        regular class, verbose getters
        Null static method         L:39-41
      ----
      **Status**: COMPLETE
    end note

    class ListDefinition {
        + name : String?
        - itemNameToValues : Map<String, Int>
        + items : Map<InkListItem, Int> <<lazy>>
        --
        + ListDefinition(name?, itemNameToValues)
        + getValueForItem(item: InkListItem) : Int?
        + containsItem(item: InkListItem) : Boolean
        + containsItemWithName(itemName: String) : Boolean
        + getItemWithValue(value: Int) : InkListItem?
    }

    note right of ListDefinition
      **ink.kt** : ListDefinition.kt:1-38
        items (by lazy)           L:19-23
        getValueForItem()         L:25 (returns Int?)
      ----
      **C#** : ListDefinition.cs:1-75
        ValueForItem returns 0 on miss
        TryGetItemWithValue uses out param
      **Java** : ListDefinition.java:1-63
        getValueForItem returns Integer?
      ----
      **Status**: COMPLETE
    end note

    class ListDefinitionsOrigin {
        - _lists : Map<String, ListDefinition>
        - _allUnambiguousListValueCache : Map<String, ListValue>
        + lists : List<ListDefinition> <<get>>
        --
        + ListDefinitionsOrigin(listDefs: List<ListDefinition>)
        + getListDefinition(name: String) : ListDefinition?
        + findSingleItemListWithName(name: String) : ListValue?
    }
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 5: STATE
' ══════════════════════════════════════════════════════════════════════════════

package "5. State" #E3F2FD {

    class StoryState {
        - rootContentContainer : Container
        - listDefsOrigin : ListDefinitionsOrigin
        - errorHandler : ErrorHandler?
        + currentErrors : MutableList<String>?
        + currentWarnings : MutableList<String>?
        + currentTurnIndex : Int
        + didSafeExit : Boolean
        + divertedPointer : Pointer
        + evaluationStack : MutableList<InkObject>
        + storySeed : Int
        + previousRandom : Int
        + variablesState : VariablesState
        + patch : StatePatch?
        + callStack : CallStack <<get>>
        + outputStream : MutableList<InkObject> <<get>>
        + currentChoices : List<Choice> <<get>>
        + canContinue : Boolean <<get>>
        + hasError : Boolean <<get>>
        + hasWarning : Boolean <<get>>
        + currentPointer : Pointer <<get/set>>
        + previousPointer : Pointer <<get/set>>
        + inExpressionEvaluation : Boolean <<get/set>>
        + currentText : String <<get>>
        + currentTags : List<String> <<get>>
        + currentPathString : String? <<get>>
        + currentFlowName : String <<get>>
        + currentFlowIsDefaultFlow : Boolean <<get>>
        + aliveFlowNames : List<String> <<get>>
        + inStringEvaluation : Boolean <<get>>
        + onDidLoadState : OnDidLoadState?
        --
        + goToStart()
        + setChosenPath(path: Path, incrementingTurnIndex: Boolean)
        + pushEvaluationStack(obj: InkObject)
        + popEvaluationStack() : InkObject
        + popEvaluationStack(n: Int) : List<InkObject>
        + peekEvaluationStack() : InkObject
        + pushToOutputStream(obj: InkObject)
        + popFromOutputStream(count: Int)
        + resetOutput(objs: List<InkObject>?)
        + popCallstack(popType: PushPopType?)
        + forceEnd()
        + switchFlowInternal(flowName: String)
        + switchToDefaultFlowInternal()
        + removeFlowInternal(flowName: String)
        + addError(message: String, isWarning: Boolean)
        + resetErrors()
        + resetWarnings()
        + visitCountForContainer(container: Container) : Int
        + incrementVisitCountForContainer(container: Container)
        + recordTurnIndexVisitToContainer(container: Container)
        + turnsSinceForContainer(container: Container) : Int
        + startFunctionEvaluationFromGame(funcContainer, arguments)
        + completeFunctionEvaluationFromGame() : Any?
        + tryExitFunctionEvaluationFromGame() : Boolean
        + copyAndStartPatching(forBackgroundSave: Boolean) : StoryState
        + restoreAfterPatch()
        + applyAnyPatch()
        + cleanOutputWhitespace(str: String) : String
        + executeOutputOp(op: OutputOp)
        + toJson() : String
        + loadJson(json: String)
        + visitCountAtPathString(pathString: String) : Int
        ~ writeJson(writer: SimpleJson.Writer)
        ~ loadJsonObj(jObject: Map<String, Any?>)
        .. companion ..
        {static} INK_SAVE_STATE_VERSION : Int = 10
        {static} MIN_COMPATIBLE_LOAD_VERSION : Int = 8
        {static} DEFAULT_FLOW_NAME : String
    }

    note right of StoryState
      **ink.kt** : StoryState.kt:1-1154
        ErrorHandler fun interface L:39-41
        OnDidLoadState fun interface L:48-50
        OutputOp enum              L:61-70
        currentText               L:214-234
        currentTags               L:236-277
        visitCountForContainer    L:610-623
        copyAndStartPatching      L:660-716
        toJson()                  L:836-840
        loadJson(json)            L:846-849
        visitCountAtPathString()  L:859-869
        writeJson(writer)         L:871-919
        loadJsonObj(jObject)      L:922-1019
        pointerAtPath()           L:1023-1040
        threadFromJson()          L:1043-1100
        flowFromJson()            L:1127-1153
      ----
      **C#** : StoryState.cs
        ToJson()/LoadJson()       ✅ Ported
        VisitCountAtPathString    ✅ Ported
      **Java** : StoryState.java
        toJson()/loadJson()       ✅ Ported
        visitCountAtPathString    ✅ Ported
      ----
      Kotlin decouples from Story (takes Container).
      **Status**: COMPLETE
    end note

    interface "StoryState.ErrorHandler" as SSErrorHandler <<fun interface>> {
        + onError(message: String, isWarning: Boolean)
    }

    interface "StoryState.OnDidLoadState" as OnDidLoadState <<fun interface>> {
        + onLoaded()
    }

    enum "StoryState.OutputOp" as OutputOp {
        DIRTY
        TRIM_NEWLINES
        REMOVE_GLUE
        TRIM_FUNCTION_END
    }

    class CallStack {
        - _threads : MutableList<InkThread>
        - _threadCounter : Int
        - _startOfRoot : Pointer
        + elements : List<Element> <<get>>
        + depth : Int <<get>>
        + currentElement : Element <<get>>
        + currentElementIndex : Int <<get>>
        + currentThread : InkThread <<get/set>>
        + canPop : Boolean <<get>>
        + canPopThread : Boolean <<get>>
        + elementIsEvaluateFromGame : Boolean <<get>>
        + threads : List<InkThread> <<get>>
        + threadCounter : Int <<get>>
        + callStackTrace : String <<get>>
        --
        + CallStack(rootContentContainer: Container)
        + CallStack(toCopy: CallStack)
        + reset()
        + push(type: PushPopType, evalStackHeight, outputStreamLen)
        + pop(type: PushPopType?)
        + canPop(type: PushPopType?) : Boolean
        + pushThread()
        + popThread()
        + forkThread() : InkThread
        + threadWithIndex(index: Int) : InkThread?
        + getTemporaryVariableWithName(name, contextIndex) : InkObject?
        + setTemporaryVariable(name, value, declareNew, contextIndex)
        + contextForVariableNamed(name: String) : Int
        + setJsonToken(threads, threadCounter, startOfRoot)
        + writeJson(writer: SimpleJson.Writer)
    }

    note right of CallStack
      **ink.kt** : CallStack.kt:1-320
        reset()                   L:165
        push()                    L:177 (default params)
        setTemporaryVariable      L:235 (FIXED Java bug)
        writeJson()               L:285-297
        callStackTrace            L:304-320
      ----
      **C#** : CallStack.cs
        WriteJson()               ✅ Ported
      **Java** : CallStack.java
        setTemporaryVariable      L:384 INFINITE RECURSION BUG
        (3-arg calls itself, not 4-arg)
        Kotlin default params fix this.
        writeJson()               ✅ Ported
      ----
      Kotlin decouples from Story (takes Container).
      Fixed C# typo: functionStartInOuputStream.
      InkThread renamed from Thread (avoids java.lang.Thread clash).
      **InkThread = coroutine of InkFlow<T>:**
        Ink ""<-"" thread syntax → coroutine launch (cooperative).
        Ink ""->>"" tunnel syntax → suspend/resume.
        Each InkThread = lightweight narrative coroutine.
        On JS: single-threaded cooperative scheduling.
        On JVM: real parallelism via Dispatchers.Default.
      **Status**: COMPLETE + COROUTINE_MODEL
    end note

    class "CallStack.Element" as CSElement {
        + type : PushPopType
        + currentPointer : Pointer
        + inExpressionEvaluation : Boolean
        + temporaryVariables : LinkedHashMap<String, InkObject>
        + evaluationStackHeightWhenPushed : Int
        + functionStartInOutputStream : Int
        --
        + Element(type, pointer, inExprEval)
        + copy() : Element
    }

    class "CallStack.InkThread" as CSThread {
        + callstack : MutableList<Element>
        + threadIndex : Int
        + previousPointer : Pointer
        --
        + InkThread()
        + InkThread(other: InkThread)
        + copy() : InkThread
        + writeJson(writer: SimpleJson.Writer)
    }

    class "InkFlow\n: Flow<InkObject>" as InkFlow <<reactive>> {
        + name : String
        + callStack : CallStack
        + outputStream : MutableList<InkObject>  <<EmittingList>>
        + currentChoices : MutableList<Choice>
        - _sharedFlow : MutableSharedFlow<InkObject>
        --
        + InkFlow(name: String, rootContentContainer: Container)
        + {abstract} collect(collector: FlowCollector<InkObject>)  <<suspend>>
        + writeJson(writer: SimpleJson.Writer)
        + loadFlowChoiceThreads(jChoiceThreads, activeCallStack)
    }

    class "EmittingList\n(internal)" as EmittingList <<bridge>> {
        - flow : MutableSharedFlow<InkObject>
        - delegate : MutableList<InkObject>
        --
        + add(element: InkObject) : Boolean  <<emits>>
        + addAll(elements: Collection<InkObject>) : Boolean  <<emits>>
        + set(index: Int, element: InkObject) : InkObject  <<emits>>
    }

    note right of InkFlow
      **ink.kt** : InkFlow.kt:1-170 (reactive stream)
        **Implements Flow<InkObject>** — reactive story output stream.
        InkFlow(name, rootContentContainer)  L:45
        collect(FlowCollector)               L:83 (suspend, delegates to SharedFlow)
        writeJson()                          L:88-130
        loadFlowChoiceThreads                L:137-155
        _sharedFlow (MutableSharedFlow)      L:57 (extraBufferCapacity=MAX)
      ----
      **Architecture: InkThread = coroutine of InkFlow**
        Each InkThread is a narrative coroutine within this flow.
        Ink ""<-"" syntax = launch coroutine (cooperative, non-blocking).
        Ink ""->>"" tunnel = suspend/resume (structured concurrency).
        On JS: single-threaded event loop (cooperative scheduling).
        On JVM: Dispatchers.Default for real parallelism.
      ----
      **Multi-tenant MMO support:**
        Each player session creates its own Story instance.
        Story → StoryState → InkFlow(s) — all per-session.
        Compiled Container is **shared** (read-only, thread-safe).
        InkFlow(s) emit to independent Flow<InkObject> streams.
        Collectors per session: UI, AI, logging, asset pipeline.
      ----
      **EmittingList** bridges sync engine → reactive Flow:
        outputStream.add() → tryEmit() to SharedFlow (lock-free).
        Zero overhead when no collectors subscribed.
        Int.MAX_VALUE buffer — tryEmit never fails.
      ----
      **C#** : Flow.cs (events: onDidContinue, onMakeChoice)
        Flow(name, Story)         → KT: InkFlow(name, Container)
        WriteJson()               ✅ Ported
        C# events → KT SharedFlow (reactive, multiplatform)
      **Java** : Flow.java (callbacks: VariableObserver, ErrorHandler)
        Flow(name, Story)         → KT: InkFlow(name, Container)
        writeJson()               ✅ Ported
        Java callbacks → KT Flow collectors
      **JS** : Flow (single-threaded, no real parallelism)
        Flow(name, story)         → KT: InkFlow(name, Container)
        JS event loop → KT coroutines (cooperative on all targets)
      ----
      **Status**: COMPLETE + REACTIVE + MMO
    end note

    note as N_THREADS_FLOWS
      **Threads, Flows, and Reactive Streams — Four-Way Comparison**
      ═══════════════════════════════════════════════════════════════

      **1. Ink Concepts vs Runtime Concepts**

      | Ink Language | C# impl | Java (blade-ink) | JS (inkjs) | Kotlin (ink.kt) |
      | ""flow"" (named execution) | Flow class | Flow class | Flow class | InkFlow : Flow<InkObject> |
      | ""<-"" thread fork | Thread (nested class) | Thread (static inner) | Thread (namespace) | InkThread (nested class) |
      | ""->>"" tunnel | CallStack.push/pop(Tunnel) | CallStack.push/pop(Tunnel) | same | same + suspend model |
      | output stream | List<Object> | ArrayList<RTObject> | Array | EmittingList (→ SharedFlow) |
      | choices | List<Choice> | List<Choice> | Array<Choice> | MutableList<Choice> |

      **2. Java blade-ink Flow (non-reactive)**

      ""Flow.java"" (blade-ink):
        • Constructor: ""Flow(name, Story)"" — takes Story reference.
        • ""callStack"": CallStack — owns call stack.
        • ""outputStream"": ""ArrayList<RTObject>"" — **plain list, no observers**.
        • ""currentChoices"": ""ArrayList<Choice>"" — plain list.
        • ""writeJson()"": manual SimpleJson.Writer serialization.
        • ""loadFlowChoiceThreads()"": restores thread snapshots from saved state.
        • **Thread**: ""CallStack.Thread"" (static inner class).
          — ""callstack"": ""ArrayList<Element>"", ""threadIndex"": int.
          — Mutable, copied by constructor ""Thread(other)"".
          — BUG: CallStack.setTemporaryVariable 3-arg infinite recursion.
        • **No reactivity**: consumers must poll outputStream after continueStory().

      **3. Kotlin ink.kt InkFlow (reactive stream)**

      ""InkFlow.kt"" (ink.kt):
        • Constructor: ""InkFlow(name, Container)"" — decoupled from Story.
        • Implements **kotlinx.coroutines.flow.Flow<InkObject>**.
        • ""_sharedFlow"": MutableSharedFlow(extraBufferCapacity=MAX) — hot stream.
        • ""outputStream"": **EmittingList** — bridges sync mutations to reactive flow.
        • ""collect()"": suspend, delegates to _sharedFlow.collect().
        • **InkThread**: ""CallStack.InkThread"" (nested class).
          — Renamed from ""Thread"" (avoids java.lang.Thread clash).
          — ""callstack"": MutableList<Element>, ""threadIndex"": Int.
          — Clean copy() via constructor.
          — **Conceptually = coroutine** of InkFlow:
            Ink ""<-"" → launch (cooperative, non-blocking).
            Ink ""->>"" → suspend/resume (structured concurrency).
            On JS: single-threaded cooperative scheduling.
            On JVM: Dispatchers.Default for real parallelism.

      **4. Kotlin Flow vs Project Reactor**

      | Pattern | Kotlin Flow (ink.kt uses this) | Project Reactor |
      | Cold stream | ""flow { emit(x) }"" | ""Flux.create { sink -> }"" |
      | Hot stream | ""MutableSharedFlow"" (**ink.kt uses this**) | ""Sinks.many().multicast()"" |
      | Collect | ""flow.collect { }"" (suspend) | ""flux.subscribe { }"" (callback) |
      | Back pressure: unbounded | ""buffer(UNLIMITED)"" / ""extraBufferCapacity=MAX"" | ""onBackpressureBuffer()"" |
      | Back pressure: drop oldest | ""buffer(n, DROP_OLDEST)"" / ""conflate()"" | ""onBackpressureDrop()"" |
      | Back pressure: latest only | ""collectLatest { }"" | ""onBackpressureLatest()"" |
      | Split (one → many) | ""SharedFlow"" + ""filter { }"" / ""filterIsInstance<T>()"" | ""Flux.share()"" + ""filter()"" |
      | Join / merge (many → one) | ""merge(flow1, flow2)"" | ""Flux.merge(f1, f2)"" |
      | Concat (sequential) | ""flowOf(f1, f2).flattenConcat()"" | ""Flux.concat(f1, f2)"" |
      | Zip | ""f1.zip(f2) { a, b -> }"" | ""Flux.zip(f1, f2)"" |
      | Combine latest | ""combine(f1, f2) { a, b -> }"" | ""Flux.combineLatest(f1, f2)"" |
      | FlatMap | ""flow.flatMapMerge { }"" | ""Flux.flatMap { }"" |
      | List → Flow | ""list.asFlow()"" | ""Flux.fromIterable(list)"" |
      | Flow → List | ""flow.toList()"" (suspend, terminal) | ""flux.collectList().block()"" |

      **5. Why Kotlin Flow (not Reactor) for ink.kt**

      • **KMP**: Flow works on JVM + JS + Native. Reactor is JVM-only.
      • **Coroutines**: Ktor is suspend-based; Flow integrates natively.
      • **No Spring**: Server uses Ktor, not Spring WebFlux.
      • **Lightweight**: No separate reactive scheduler; coroutine dispatchers suffice.
      • **RSocket-Kotlin**: rsocket-kotlin uses Flow, not Publisher.
      • **Camel bridge**: CamelRoutes uses direct: endpoints (sync);
        Flow consumed in WebSocket handlers and MCP tool processors.

      **6. InkFlow back pressure design choice**

      ""extraBufferCapacity = Int.MAX_VALUE"" means:
        • ""tryEmit()"" **always succeeds** — no backpressure on the ink engine.
        • Items buffered when collectors are slow; dropped when none subscribed.
        • **Trade-off**: unbounded memory if collector stalls indefinitely.
        • **Rationale**: ink engine is synchronous (single continueStory call
          produces a burst of InkObjects). Backpressure would deadlock the engine.
        • **For asset streaming (RSocket/WS)**: the WebSocket handler in
          McpRouter uses ""launch { send(...) }"" — Ktor WS provides TCP
          backpressure at the transport layer.

      **7. Threading model per platform**

      | Platform | InkThread execution | Dispatcher | Parallelism |
      | JVM | Coroutine via Dispatchers.Default | Thread pool | Real parallelism |
      | JS | Coroutine via event loop | Single-threaded | Cooperative only |
      | Native | Coroutine via Dispatchers.Default | Worker pool | Real parallelism |
    end note

    N_THREADS_FLOWS .. InkFlow

    class StatePatch {
        + globals : LinkedHashMap<String, InkObject>
        + changedVariables : LinkedHashSet<String>
        + visitCounts : LinkedHashMap<Container, Int>
        + turnIndices : LinkedHashMap<Container, Int>
        --
        + StatePatch(toCopy: StatePatch? = null)
        + getGlobal(name: String) : InkObject?
        + setGlobal(name: String, value: InkObject)
        + addChangedVariable(name: String)
        + getVisitCount(container: Container) : Int?
        + setVisitCount(container: Container, count: Int)
        + getTurnIndex(container: Container) : Int?
        + setTurnIndex(container: Container, index: Int)
    }

    note right of StatePatch
      **ink.kt** : StatePatch.kt:1-54
        globals (LinkedHashMap)   L:21
        changedVariables          L:24
        visitCounts               L:27
        turnIndices               L:30
      ----
      **C#** : StatePatch.cs
        TryGetGlobal (out param) — KT returns nullable
        TryGetVisitCount (out param) — KT returns nullable
      **Java** : StatePatch.java
        HashMap/HashSet (no order guarantee)
      ----
      Kotlin: LinkedHashMap + nullable returns
      (vs C# TryGet out-param, Java null-check).
      **Status**: COMPLETE
    end note

    class VariablesState <<Iterable<String>>> {
        - _globalVariables : LinkedHashMap<String, InkObject>
        - _defaultGlobalVariables : LinkedHashMap<String, InkObject>?
        - _batchObservingVariableChanges : Boolean
        - _changedVariablesForBatchObs : LinkedHashSet<String>?
        + variableChangedEvent : VariableChanged?
        + patch : StatePatch?
        + callStack : CallStack <<get/set>>
        + globalVariables : LinkedHashMap<String, InkObject> <<get>>
        + dontSaveDefaultValues : Boolean
        --
        + VariablesState(callStack, listDefsOrigin)
        + operator get(variableName: String) : Any?
        + operator set(variableName: String, value: Any?)
        + iterator() : Iterator<String>
        + assign(varAss: VariableAssignment, value: InkObject)
        + getVariableWithName(name, contextIndex) : InkObject?
        + getRawVariableWithName(name, contextIndex) : InkObject?
        + valueAtVariablePointer(pointer: VariablePointerValue) : InkObject?
        + globalVariableExistsWithName(name: String) : Boolean
        + tryGetDefaultVariableValue(name: String) : InkObject?
        + setGlobal(variableName: String, value: InkObject)
        + runtimeObjectsEqual(obj1, obj2) : Boolean
        + startVariableObservation()
        + completeVariableObservation() : LinkedHashMap<String, InkObject>
        + notifyObservers(changedVars: Map<String, InkObject>)
        + applyPatch()
        + setJsonToken(jToken: Map<String, Any?>)
        + snapshotDefaultGlobals()
        .. companion ..
        {static} dontSaveDefaultValuesGlobal : Boolean
    }

    note right of VariablesState
      **ink.kt** : VariablesState.kt:1-340
        operator get/set          L:59-86
        assign()                  L:128-166
        writeJson(writer)         L:327-340
        setGlobal()               L:270-293
        runtimeObjectsEqual()     L:299-308
        fun interface VariableChanged L:32
      ----
      **C#** : VariablesState.cs
        IEnumerable<string>, delegate, indexer
        WriteJson()               ✅ Ported
      **Java** : VariablesState.java
        Iterable<String>, get/set methods
        writeJson()               ✅ Ported
      ----
      **Status**: COMPLETE
    end note

    interface "VariablesState.VariableChanged" as VarChanged <<fun interface>> {
        + onVariableChanged(variableName: String, newValue: InkObject)
    }
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 6: RUNTIME
' ══════════════════════════════════════════════════════════════════════════════

package "6. Runtime" #E3F2FD {

    class Story {
        - mainContentContainer : Container?
        - listDefinitions : ListDefinitionsOrigin?
        - allowExternalFunctionFallbacks : Boolean
        - externals : HashMap<String, ExternalFunctionDef>
        - hasValidatedExternals : Boolean
        - temporaryEvaluationContainer : Container?
        - variableObservers : HashMap<String, MutableList<VariableObserver>>?
        - profiler : Profiler?
        - asyncContinueActive : Boolean
        - stateSnapshotAtLastNewline : StoryState?
        - recursiveContinueCount : Int
        + state : StoryState
        + onError : ErrorHandler?
        + onDidContinue : (() -> Unit)?
        + onMakeChoice : ((Choice) -> Unit)?
        + onEvaluateFunction : ((String, Array<Any?>) -> Unit)?
        + onCompleteEvaluateFunction : ((String, Array<Any?>, String, Any?) -> Unit)?
        + onChoosePathString : ((String, Array<Any?>?) -> Unit)?
        + currentChoices : List<Choice> <<get>>
        + currentText : String <<get>>
        + currentTags : List<String> <<get>>
        + currentErrors : List<String>? <<get>>
        + currentWarnings : List<String>? <<get>>
        + variablesState : VariablesState <<get>>
        + listDefinitionsOrigin : ListDefinitionsOrigin? <<get>>
        + hasError : Boolean <<get>>
        + hasWarning : Boolean <<get>>
        + currentFlowName : String <<get>>
        + aliveFlowNames : List<String> <<get>>
        + mainContent : Container <<get>>
        + allowExternalFallbacks : Boolean <<get/set>>
        --
        + Story(contentContainer: Container, lists?)
        + Story(jsonString: String)
        + canContinue() : Boolean
        + continueStory() : String
        + continueMaximally() : String
        + continueAsync(millisecsLimitAsync: Float)
        + continueSingleStep() : Boolean
        + asyncContinueComplete() : Boolean
        + chooseChoiceIndex(choiceIdx: Int)
        + choosePathString(path, resetCallstack, arguments)
        + switchFlow(flowName: String)
        + removeFlow(flowName: String)
        + switchToDefaultFlow()
        + bindExternalFunction(funcName, func, lookaheadSafe)
        + unbindExternalFunction(funcName: String)
        + getExternalFunction(name: String) : ExternalFunction?
        + getGlobalTags() : List<String>?
        + tagsForContentAtPath(path: String) : List<String>?
        + observeVariable(variableName, observer)
        + observeVariables(variableNames, observer)
        + removeVariableObserver(observer, specificVariableName?)
        + evaluateExpression(exprContainer: Container) : InkObject?
        + evaluateFunction(functionName, arguments?) : Any?
        + evaluateFunction(functionName, textOutput, arguments) : Any?
        + hasFunction(functionName: String) : Boolean
        + contentAtPath(path: Path) : SearchResult
        + startProfiling() : Profiler
        + endProfiling()
        + toJson() : String
        + resetState()
        + resetCallstack()
        + resetErrors()
        + validateExternalBindings()
        + buildStringOfHierarchy() : String
        + copyStateForBackgroundThreadSave() : StoryState
        + backgroundSaveComplete()
        + onVariableChanged(variableName, newValue)
        .. companion ..
        {static} INK_VERSION_CURRENT : Int = 21
        {static} INK_VERSION_MINIMUM_COMPATIBLE : Int = 18
    }

    note right of Story
      **ink.kt** : Story.kt:1-2100+
        ExternalFunction fun interface  L:33-36
        VariableObserver fun interface  L:41-43
        ExternalFunctionDef class       L:45-48
        mainContentContainer            L:54
        state                           L:60 (private setter)
        onError/onDidContinue/etc.      L:74-101
        Story(Container, lists?)        L:103
        Story(jsonString)               L:112
        continueStory()                 L:130+
        continueMaximally()             L:207
        continueAsync()                 L:224
        chooseChoiceIndex()             L:260
        choosePathString()              L:280
        switchFlow()                    L:350
        bindExternalFunction()          L:470
        evaluateFunction()              L:550
        toJson()                        L:1640
        resetState()                    L:1741
      ----
      **C#** : Story.cs:1-3050
        delegates for externals
        Stream overloads (ToJson)
        ContinueAsync()
      **Java** : Story.java:1-2928
        ExternalFunction0/1/2/3 abstract classes
        implements VariableChanged
        continueStory()
      ----
      Kotlin: fun interface SAM replaces
      4 Java abstract classes.
      when expressions for dispatch.
      **Status**: COMPLETE
      (missing only toJson(Appendable) stream overload)
    end note

    interface "Story.ExternalFunction" as ExtFunc <<fun interface>> {
        + call(args: Array<out Any?>) : Any?
    }

    interface "Story.VariableObserver" as VarObserver <<fun interface>> {
        + call(variableName: String, newValue: Any?)
    }

    class Profiler {
        - continueWatch : Stopwatch
        - stepWatch : Stopwatch
        - snapWatch : Stopwatch
        - continueTotal : Double
        - snapTotal : Double
        - stepTotal : Double
        + rootNode : ProfileNode
        - numContinues : Int
        - stepDetails : MutableList<StepDetails>
        --
        + report() : String
        + stepLengthReport() : String
        + megalog() : String
        ~ preContinue()
        ~ postContinue()
        ~ preStep()
        ~ step(callstack: CallStack)
        ~ postStep()
        ~ preSnapshot()
        ~ postSnapshot()
        .. companion ..
        {static} formatMillisecs(num: Double) : String
    }

    note right of Profiler
      **Kotlin:** ProfileNode as top-level class
      (same file). ""data class StepDetails"".
      ""buildString"", ""sortedByDescending"".
      **C#:** Profiler + ProfileNode (separate files).
      **Java:** Profiler + ProfileNode (separate files).
      **JS:** not implemented.
    end note

    class ProfileNode {
        + key : String?
        - nodes : HashMap<String, ProfileNode>?
        - selfMillisecs : Double
        + totalMillisecs : Double
        - selfSampleCount : Int
        - totalSampleCount : Int
        + openInUI : Boolean
        + hasChildren : Boolean <<get>>
        + descendingOrderedNodes : List<...>? <<get>>
        + ownReport : String <<get>>
        --
        + ProfileNode(key: String? = null)
        ~ addSample(stack: Array<String>, duration: Double)
        + toString() : String
    }
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 7: SERIALIZATION
' ══════════════════════════════════════════════════════════════════════════════

package "7. Serialization" #F3E5F5 {

    object SimpleJson {
        + textToDictionary(text: String) : LinkedHashMap<String, Any?>
        + textToArray(text: String) : List<Any?>
    }

    class "SimpleJson.Reader" as SJReader <<internal>> {
        - text : String
        - offset : Int
        - rootObject : Any?
        --
        + Reader(text: String)
        + toDictionary() : LinkedHashMap<String, Any?>
        + toArray() : List<Any?>
        - readObject() : Any?
        - readDictionary() : LinkedHashMap<String, Any?>
        - readArray() : MutableList<Any?>
        - readString() : String
        - readNumber() : Any
        - tryRead(textToRead: String) : Boolean
        - expect(expectedStr: String)
        - skipWhitespace()
    }

    note right of SJReader
      **ink.kt** : SimpleJson.kt:42-270
        Reader(text)              L:42
        offset/rootObject         L:44-45
        toDictionary()            L:52
        readObject()              L:70 (dispatch)
        readDictionary()          L:93
        readArray()               L:133
        readString()              L:164
        readNumber()              L:215
        tryRead()                 L:244
        skipWhitespace()          L:261
      ----
      **C#** : SimpleJson.cs (private nested)
        ReadObject() recursive descent
      **Java** : SimpleJson.java (static inner)
        readObject() recursive descent
      ----
      Kotlin: internal visibility.
      **Status**: COMPLETE
    end note

    class "SimpleJson.Writer" as SJWriter {
        - sb : StringBuilder
        - stateStack : ArrayDeque<StateElement>
        --
        + writeObject(inner: InnerWriter)
        + writeObjectStart()
        + writeObjectEnd()
        + writeProperty(name: String, inner: InnerWriter)
        + writeProperty(name: String, content: String)
        + writeProperty(name: String, content: Int)
        + writeProperty(name: String, content: Boolean)
        + writePropertyStart(name: String)
        + writePropertyEnd()
        + writePropertyNameStart()
        + writePropertyNameEnd()
        + writePropertyNameInner(str: String)
        + writeArrayStart()
        + writeArrayEnd()
        + write(i: Int)
        + write(f: Float)
        + write(str: String, escape: Boolean)
        + write(b: Boolean)
        + writeNull()
        + writeStringStart()
        + writeStringEnd()
        + writeStringInner(str: String, escape: Boolean)
        + clear()
        + toString() : String
    }

    note right of SJWriter
      **ink.kt** : SimpleJson.kt:289-558
        sb (StringBuilder)        L:291
        stateStack (ArrayDeque)   L:292
        writeObject()             L:296
        writeProperty() x5       L:316-344
        writeArrayStart/End       L:397-407
        write(Int/Float/String/Boolean) L:411-450
        writeEscapedString()      L:491
        startNewObject()          L:512
        State enum                L:545
        StateElement class        L:555
      ----
      **C#** : SimpleJson.cs
        supports StringWriter + Stream
      **Java** : SimpleJson.java
        StringWriter + OutputStream
      ----
      Kotlin: StringBuilder only (no Stream).
      ArrayDeque stack (no sync overhead).
      commonMain compatible.
      **Status**: COMPLETE
    end note

    interface "SimpleJson.InnerWriter" as InnerWriter <<fun interface>> {
        + write(w: Writer)
    }

    object JsonSerialisation {
        + writeListRuntimeObjs(writer, list)
        + writeDictionaryRuntimeObjs(writer, dictionary)
        + writeIntDictionary(writer, dict)
        + writeRuntimeObject(writer, obj)
        + writeRuntimeContainer(writer, container, withoutName)
        + writeChoice(writer, choice)
        + jArrayToRuntimeObjList(jArray, skipLast) : MutableList<InkObject>
        + jObjectToDictionaryRuntimeObjs(jObject) : LinkedHashMap<String, InkObject>
        + jObjectToIntDictionary(jObject) : LinkedHashMap<String, Int>
        + jTokenToRuntimeObject(token: Any?) : InkObject?
        + listDefinitionsToJToken(origin) : LinkedHashMap<String, Any?>
        + jTokenToListDefinitions(obj: Any?) : ListDefinitionsOrigin
        - controlCommandNames : Array<String>
    }

    note right of JsonSerialisation
      **ink.kt** : JsonSerialisation.kt:1-669
        writeListRuntimeObjs()    L:45
        writeRuntimeObject()      L:77 (when dispatch)
        jArrayToRuntimeObjList()  L:193
        jTokenToRuntimeObject()   L:232 (when dispatch)
        writeRuntimeContainer()   L:441
        writeChoice()             L:506
        writeInkList()            L:549
        listDefinitionsToJToken() L:587
        jTokenToListDefinitions() L:600
        controlCommandNames[]     L:628
      ----
      **C#** : JsonSerialisation.cs:1-751
        static class Json
        JArrayToRuntimeObjList<T>()
        WriteChoice()
      **Java** : Json.java:1-751+
        static class Json
        jArrayToRuntimeObjList()
        writeChoice()
      ----
      Kotlin: object singleton, when smart casts.
      Zero 3rd-party deps. Pure Kotlin stdlib.
      **Status**: COMPLETE
    end note

    object Json <<internal>> {
        + jTokenToRuntimeObject(token: Any?) : InkObject?
    }

    note right of Json
      **ink.kt** : Json.kt (internal)
      Thin delegate to JsonSerialisation.
      Preserves call sites used by
      VariablesState.setJsonToken().
      **Status**: COMPLETE
    end note

    object StoryLoader <<mica>> {
        + load(json: JsonObject, story: Story)
        - loadValue(element: JsonElement, story: Story) : Any?
    }

    note right of StoryLoader
      **ink.kt** : StoryLoader.kt:1-67
        load()                    L:11
        loadValue()               L:59
      ----
      **mica** : StoryLoader (parser JSON format)
      Uses kotlinx.serialization.json
      (not SimpleJson).
      **Status**: COMPLETE (mica)
    end note

    object StorySaver <<mica>> {
        + save(story: Story) : JsonObject
        - putValue(builder, story, key, value)
    }

    note right of StorySaver
      **ink.kt** : StorySaver.kt:1-65
        save()                    L:11
        putValue()                L:53
      ----
      **mica** : StorySaver (parser JSON format)
      Uses kotlinx.serialization.json.
      **Status**: COMPLETE (mica)
    end note
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 8: INFRASTRUCTURE
' ══════════════════════════════════════════════════════════════════════════════

package "8. Infrastructure" #ECEFF1 {

    class Stopwatch {
        - timeSource : TimeSource.Monotonic
        - mark : TimeSource.Monotonic.ValueTimeMark?
        - stoppedDuration : Duration
        - running : Boolean
        + elapsed : Duration <<get>>
        + elapsedMilliseconds : Long <<get>>
        + elapsedNanoseconds : Long <<get>>
        + elapsedMicroseconds : Long <<get>>
        --
        + start()
        + stop()
        + reset()
    }

    note right of Stopwatch
      **ink.kt** : Stopwatch.kt:50-85
        TimeSource.Monotonic      L:51
        start()/stop()/reset()    L:56-70
        elapsed (Duration)        L:73
        elapsedMilliseconds       L:78
      ----
      **C#** : System.Diagnostics.Stopwatch (BCL)
      **Java** : Stopwatch.java:1-147
        System.nanoTime() custom impl
      ----
      Kotlin: 36 lines vs Java 147 lines.
      kotlin.time.TimeSource cross-platform.
      **Status**: COMPLETE
    end note

    object InkClock {
        + clockSource : () -> Long
        + nanoClockSource : () -> Long
        --
        + epochMillis() : Long
        + epochNanos() : Long
        + epochSeconds() : Long
        + utcIso8601() : String
        + utcBackupTimestamp() : String
        + utcICalTimestamp() : String
        + localIso8601(offsetHours, offsetMinutes) : String
        + utcDateComponents(epochMs?) : DateComponents
        + localDateComponents(offsetHours, offsetMinutes, epochMs?) : DateComponents
        + timeSeed() : Int
        + epochMillisMinusDays(days: Long) : Long
        + durationBetween(startMs, endMs) : Duration
        + resetToSystemClock()
        + setFixedClock(fixedMs: Long)
    }

    note right of InkClock
      **ink.kt** : Stopwatch.kt:121-253
        clockSource/nanoClockSource L:129,137
        epochMillis/Nanos/Seconds  L:142-148
        utcIso8601()               L:156
        utcDateComponents()        L:200
        localDateComponents()      L:207
        timeSeed()                 L:218
        setFixedClock()            L:249
        resetToSystemClock()       L:240
      ----
      Kotlin-only (not in C#/Java/JS).
      kotlinx-datetime Clock.System.
      Pluggable clockSource for testing.
      **Status**: COMPLETE (KT-only)
    end note

    class DateComponents <<data class>> {
        + year : Int
        + month : Int
        + day : Int
        + hour : Int
        + minute : Int
        + second : Int
        + millisecond : Int
        + nanosecond : Long
        + dayOfWeek : Int
        + dayOfYear : Int
    }

    class StoryException {
        + useEndLineNumber : Boolean
        --
        + StoryException(message: String?)
    }

    enum ErrorType {
        Author
        Warning
        Error
    }

    interface ErrorHandler <<fun interface>> {
        + error(message: String, type: ErrorType)
    }

    note right of ErrorHandler
      **ink.kt** : ErrorHandler defined in
        Story.kt (not separate file)
      **Java** : ErrorHandler.java:1-10
      **C#** : delegate ErrorHandler
      Kotlin: fun interface (SAM).
      **Status**: COMPLETE
    end note

    enum PushPopType {
        Tunnel
        Function
        FunctionEvaluationFromGame
    }

    note right of PushPopType
      **ink.kt** : PushPopType.kt
      **C#** : PushPop.cs
      **Java** : PushPopType.java
      All identical 3-member enum.
      **Status**: COMPLETE
    end note

    interface INamedContent {
        + name : String? <<get>>
        + hasValidName : Boolean <<get>>
    }

    note right of INamedContent
      **ink.kt** : INamedContent.kt:1-17
        name (String?)            L:14
        hasValidName              L:15
      ----
      **C#** : INamedContent.cs
      **Java** : INamedContent.java
      Implemented by Container.
      **Status**: COMPLETE
    end note

    class "InkRunTimeException" as InkRunTimeException {
        + InkRunTimeException(message: String?)
    }

    class "InkParseException" as InkParseException {
        + InkParseException(message: String?)
    }

    class "InkLoadingException" as InkLoadingException {
        + InkLoadingException(message: String?)
    }

    note right of InkRunTimeException
      **ink.kt** : exceptions from mica
      All extend RuntimeException.
      **Status**: COMPLETE (mica)
    end note
}

' ══════════════════════════════════════════════════════════════════════════════
' RELATIONSHIPS: Inheritance
' ══════════════════════════════════════════════════════════════════════════════

' Core inheritance
Container --|> InkObject
Container ..|> INamedContent

' Content inheritance
ChoicePoint --|> InkObject
Choice --|> InkObject
Divert --|> InkObject
Glue --|> InkObject
Tag --|> InkObject
InkVoid --|> InkObject
ControlCommand --|> InkObject
VariableAssignment --|> InkObject
VariableReference --|> InkObject
NativeFunctionCall --|> InkObject

' Value hierarchy (sealed class)
Value --|> InkObject
BoolValue --|> Value
IntValue --|> Value
FloatValue --|> Value
StringValue --|> Value
DivertTargetValue --|> Value
VariablePointerValue --|> Value
ListValue --|> Value

' Story implements VariablesState.VariableChanged
Story ..|> VarChanged

' Exception hierarchy
StoryException --|> Exception
InkRunTimeException --|> Exception
InkParseException --|> Exception
InkLoadingException --|> Exception

' Parser inheritance
ParameterizedContainer --|> Container
Knot --|> ParameterizedContainer
Knot ..|> Function
Stitch --|> ParameterizedContainer
Gather --|> Container
Conditional --|> Container
ConditionalOption --|> Container
Declaration --|> InkObject

' Support inheritance
VariableMapAdapter ..|> VariableMap

' ══════════════════════════════════════════════════════════════════════════════
' RELATIONSHIPS: Associations
' ══════════════════════════════════════════════════════════════════════════════

' Core associations
InkObject "0..1" --> "parent" Container
Container "1" *--> "*" InkObject : content
Container "1" *--> "*" INamedContent : namedContent
PathComponent "1..*" --* Path : _components
SearchResult --> "0..1" InkObject : obj
Pointer --> "0..1" Container : container

' Content associations
ChoicePoint --> Path : _pathOnChoice
Choice --> Path : targetPath
Choice --> "0..1" CSThread : threadAtGeneration
Divert --> Path : _targetPath
ControlCommand --> CommandType

' Value associations
DivertTargetValue --> Path : targetPath
ListValue --> InkList : value

' List associations
InkList --> "*" InkListItem : keys
InkList --> "*" ListDefinition : origins
ListDefinition --> "*" InkListItem : items
ListDefinitionsOrigin --> "*" ListDefinition : _lists
ListDefinitionsOrigin --> "*" ListValue : _allUnambiguousListValueCache

' State associations
StoryState --> Container : rootContentContainer
StoryState --> ListDefinitionsOrigin : listDefsOrigin
StoryState --> VariablesState : variablesState
StoryState --> StatePatch : patch
StoryState --> InkFlow : currentFlow
StoryState --> "*" InkFlow : namedFlows
InkFlow --> CallStack : callStack
InkFlow --> "*" Choice : currentChoices
InkFlow --> "*" InkObject : outputStream
InkFlow *-- EmittingList : outputStream (bridge)
CallStack --> "*" CSThread : _threads
CSThread --> "*" CSElement : callstack
CSElement --> Pointer : currentPointer
VariablesState --> CallStack : _callStack
VariablesState --> ListDefinitionsOrigin : _listDefsOrigin
VariablesState --> StatePatch : patch
StatePatch --> "*" Container : visitCounts / turnIndices

' Runtime associations
Story --> StoryState : state
Story --> Container : mainContentContainer
Story --> ListDefinitionsOrigin : listDefinitions
Story --> Profiler : profiler
Profiler --> "*" Stopwatch : continueWatch, stepWatch, snapWatch
Profiler --> ProfileNode : rootNode

' Serialization associations
JsonSerialisation ..> SimpleJson : uses Writer
Json ..> JsonSerialisation : delegates to
StoryLoader ..> Story : loads into
StorySaver ..> Story : saves from

' Parser associations
InkParser ..> StoryWrapper : uses for file/host access
InkParser ..> Story : creates
Expression ..> Operator : uses registered operators
Expression ..> VariableMap : evaluates against
Knot ..> VariableMap : eval uses
VariableMapAdapter --> Story : bridges to
Conditional ..> Story : resolves against
ConditionalOption ..> VariableMap : evaluates against
Declaration ..> Story : evaluates in

' Nested class ownership
NativeFunctionCall +-- BinaryOp
NativeFunctionCall +-- UnaryOp
SimpleJson +-- SJReader
SimpleJson +-- SJWriter
SimpleJson +-- InnerWriter
CallStack +-- CSElement
CallStack +-- CSThread
StoryState +-- SSErrorHandler
StoryState +-- OnDidLoadState
StoryState +-- OutputOp
Story +-- ExtFunc
Story +-- VarObserver
VariablesState +-- VarChanged
ControlCommand +-- CommandType
Conditional +-- SeqType
Expression +-- GameObjResolver

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 9: PARSER (mica → ink.kt)
' ══════════════════════════════════════════════════════════════════════════════

package "9. Parser" #FFF8E1 {

    object InkParser <<mica>> {
        + parse(provider: StoryWrapper, fileName: String) : Story
        + parse(input: String, provider: StoryWrapper, fileName: String) : Story
        - parseLine(lineNumber, line, currentContainer) : List<InkObject>
        - parseContainer(cont: InkObject) : MutableList<InkObject>
        - isConditional(currentContainer: Container?) : Boolean
        - getConditional(currentContainer: Container) : Container
        ~ parseDivert(lineNumber, line, currentContainer) : List<InkObject>
    }

    note right of InkParser
      **ink.kt** : InkParser.kt:1-174
        parse(provider,fileName) L:9
        parse(input,provider,fn) L:14
        parseLine()              L:65 (line-by-line dispatch)
        parseContainer()         L:125
        parseDivert()            L:151
      ----
      **mica** : InkParser (line-by-line parser)
      Parses raw .ink text into Container tree.
      No C#/Java/JS equivalent (those use inklecate).
      **Status**: COMPLETE (mica-only)
    end note

    class Expression <<mica>> {
        - rpn : List<String>?
        - operators : SortedMap<String, Operator>
        - expression : String
        + gameObjectResolver : GameObjectResolver?
        --
        + Expression(originalExpression: String)
        - shuntingYard(expression, vMap) : List<String>
        + eval(vMap: VariableMap) : Any
        - addOperator(oper: Operator)
        - getRPN(vMap: VariableMap) : List<String>
        - validate(rpn, vMap)
        + toString() : String
        .. companion ..
        {static} PI : Double
        {static} e : Double
        {static} defaultGameObjectResolver : GameObjectResolver
        {static} isNumber(st: String) : Boolean
    }

    note right of Expression
      **ink.kt** : Expression.kt:1-529
        Expression(originalExpr) L:13
        Tokenizer inner class    L:38-126
        init (operator setup)    L:128-232
        shuntingYard()           L:234
        eval()                   L:327
        LazyNumber interface     L:473
      ----
      **mica** : Expression evaluator
      Shunting-yard algorithm for math.
      GameObjectResolver fun interface
      replaces Java reflection.
      **Status**: COMPLETE (mica)
    end note

    interface "Expression.GameObjectResolver" as GameObjResolver <<fun interface>> {
        + call(obj: Any, method: String, params: List<Any>) : Any
    }

    class Knot <<mica>> {
        ~ isFunction : Boolean
        + isFixedNumParams : Boolean
        + numParams : Int <<get>>
        --
        + Knot(header: String, lineNumber: Int)
        + eval(params: List<Any>, vMap: VariableMap) : Any
        .. companion ..
        {static} isKnot(str: String) : Boolean
        {static} getId(id: String) : String
        {static} isFunction(id: String) : Boolean
    }

    note right of Knot
      **ink.kt** : Knot.kt:1-97
        extends ParameterizedContainer
        implements Function
        isFunction                L:13
        eval()                    L:18
        getId()                   L:77 (companion)
      ----
      **mica** : Knot = named content block
      (== knot_name)
      **Status**: COMPLETE (mica)
    end note

    class Stitch <<mica>> {
        --
        + Stitch(header, parent, lineNumber)
        .. companion ..
        {static} isStitchHeader(str: String) : Boolean
        {static} getId(header, parent) : String
        {static} getParent(currentContainer) : Container
    }

    note right of Stitch
      **ink.kt** : Stitch.kt:1-40
        extends ParameterizedContainer
        isStitchHeader()          L:17
        getId()                   L:19
        getParent()               L:30
      ----
      **mica** : Stitch = sub-section
      (= stitch_name)
      **Status**: COMPLETE (mica)
    end note

    class Gather <<mica>> {
        + level : Int
        --
        + Gather(text, parent, level, lineNumber)
        .. companion ..
        {static} getChoiceDepth(line: String) : Int
        {static} getId(text, parent) : String
        {static} getParent(currentContainer, lvl) : Container
    }

    note right of Gather
      **ink.kt** : Gather.kt:1-72
        extends Container
        level                     L:6
        getChoiceDepth()          L:36
        getParent()               L:61
      ----
      **mica** : Gather point (- dash lines)
      **Status**: COMPLETE (mica)
    end note

    class Conditional <<mica>> {
        - seqType : SequenceType
        --
        + Conditional(header, parent, lineNumber)
        + resolveConditional(story: Story) : Container
        - verifySequenceCondition(str: String)
        .. companion ..
        {static} isConditionalHeader(str: String) : Boolean
        {static} getId(parent: Container) : String
    }

    note right of Conditional
      **ink.kt** : Conditional.kt:1-86
        extends Container
        SequenceType enum         L:11-17
        resolveConditional()      L:41
        isConditionalHeader()     L:80
      ----
      **mica** : { conditional | sequence }
      **Status**: COMPLETE (mica)
    end note

    enum "Conditional.SequenceType" as SeqType <<mica>> {
        SEQUENCE_NONE
        SEQUENCE_CYCLE
        SEQUENCE_ONCE
        SEQUENCE_SHUFFLE
        SEQUENCE_STOP
    }

    class ConditionalOption <<mica>> {
        --
        + ConditionalOption(condition, parent, lineNumber)
        + evaluate(vMap: VariableMap) : Boolean
        .. companion ..
        {static} getCondition(txt: String) : String
    }

    note right of ConditionalOption
      **ink.kt** : ConditionalOption.kt:1-48
        extends Container
        evaluate()                L:31
        getCondition()            L:37
      ----
      **mica** : individual branch in conditional
      **Status**: COMPLETE (mica)
    end note

    class Declaration <<mica>> {
        - isDeclaration : Boolean
        --
        + Declaration(lineNumber, decl, parent)
        + evaluate(story: Story)
        - declareVariable(story: Story)
        - calculate(story: Story)
        .. companion ..
        {static} VAR_ : String
        {static} TILDE_ : String
        {static} getId(parent) : String
        {static} evaluate(str, variables) : Any
        {static} isVariableHeader(str) : Boolean
    }

    note right of Declaration
      **ink.kt** : Declaration.kt:1-101
        extends InkObject
        evaluate()                L:20
        declareVariable()         L:27
        calculate()               L:50
        isVariableHeader()        L:98
      ----
      **mica** : VAR x = ... / ~ x = ...
      **Status**: COMPLETE (mica)
    end note

    class ParameterizedContainer <<mica>> {
        + parameters : List<String>
        ~ values : MutableMap<String, Any>
        --
        + ParameterizedContainer(id, parameters, parent?, lineNumber)
        + hasValue(key: String) : Boolean
        + getValue(key: String) : Any
        + setValue(key: String, value: Any)
        .. companion ..
        {static} getParameters(header: String) : List<String>
    }

    note right of ParameterizedContainer
      **ink.kt** : ParameterizedContainer.kt:1-42
        extends Container (open)
        parameters                L:5
        values                    L:17
        getParameters()           L:28
      ----
      **mica** : base for Knot/Stitch
      **Status**: COMPLETE (mica)
    end note
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 10: SUPPORT (mica → ink.kt)
' ══════════════════════════════════════════════════════════════════════════════

package "10. Support" #E8F5E9 {

    object StoryText <<mica>> {
        + getText(text, count, variables) : String
        - evaluateText(str, count, variables) : String
        - evaluateTextVariable(s, variables) : String
        - evaluateSequenceText(str, count) : String
        - evaluateShuffleText(str) : String
        - evaluateOnceOnlyText(str, count) : String
        - evaluateCycleText(str, count) : String
        - evaluateConditionalText(str, variables) : String
    }

    note right of StoryText
      **ink.kt** : StoryText.kt:1-117
        getText()                 L:8
        evaluateText()            L:24
        evaluateSequenceText()    L:47
        evaluateConditionalText() L:71
      ----
      **mica** : dynamic text evaluation
      Called by InkObject.getText()
      **Status**: COMPLETE (mica)
    end note

    object Symbol <<mica>> {
        {static} BRACE_LEFT : Char = '('
        {static} BRACE_RIGHT : Char = ')'
        {static} CBRACE_LEFT : Char
        {static} CBRACE_RIGHT : Char
        {static} CHOICE_DOT : Char = '*'
        {static} CHOICE_PLUS : Char = '+'
        {static} COMMENT : String = "//"
        {static} DIVERT : String = "->"
        {static} GLUE : String = "<>"
        {static} INCLUDE : String = "INCLUDE"
        {static} FUNCTION : String = "function"
        {static} RETURN : String = "return"
    }

    note right of Symbol
      **ink.kt** : Symbol.kt:1-36
        30 syntax constants
      ----
      **mica** : parser syntax constants
      **Status**: COMPLETE (mica)
    end note

    abstract class Operator <<mica>> {
        + oper : String
        + precedence : Int
        + isLeftAssoc : Boolean
        --
        + {abstract} eval(v1: Any, v2: Any) : Any
    }

    note right of Operator
      **ink.kt** : Operator.kt:1-15
        abstract eval()           L:13
      ----
      **mica** : used by Expression shunting-yard
      **Status**: COMPLETE (mica)
    end note

    object StoryJson <<mica>> {
        {static} FILE : String
        {static} FILES : String
        {static} CONTENT : String
        {static} ID : String
        {static} VARIABLES : String
        {static} CONTAINER : String
        {static} TEXT : String
        {static} CHOICES : String
    }

    note right of StoryJson
      **ink.kt** : StoryJson.kt:1-20
        14 JSON key constants
      ----
      **mica** : parser JSON format keys
      (different from compiled JSON keys)
      **Status**: COMPLETE (mica)
    end note

    interface StoryWrapper <<mica>> {
        + getFileContent(fileId: String) : String
        + getStoryObject(objId: String) : Any
        + getInterrupt(s: String) : StoryInterrupt
        + resolveTag(t: String)
        + logDebug(m: String)
        + logError(m: String)
        + logException(e: Exception)
    }

    note right of StoryWrapper
      **ink.kt** : StoryWrapper.kt:1-17
        7 methods for story host
      ----
      **mica** : host callback interface
      Used by InkParser/Story parser mode
      **Status**: COMPLETE (mica)
    end note

    abstract class StoryInterrupt <<mica>> {
        + id : String
        + text : String
        + condition : String
        + file : String
        + isChoice : Boolean
        + isDivert : Boolean
        + isActive : Boolean
    }

    note right of StoryInterrupt
      **ink.kt** : StoryInterrupt.kt:1-13
        isChoice (starts with */+) L:9
        isDivert (starts with ->) L:10
      ----
      **mica** : flow override mechanism
      **Status**: COMPLETE (mica)
    end note

    interface VariableMap <<mica>> {
        + logException(e: Exception)
        + hasValue(token: String) : Boolean
        + getValue(token: String) : Any
        + hasFunction(token: String) : Boolean
        + getFunction(token: String) : Function
        + hasGameObject(token: String) : Boolean
        + debugInfo() : String
    }

    note right of VariableMap
      **ink.kt** : VariableMap.kt:1-13
        7 methods for variable access
      ----
      **mica** : parser variable contract
      Implemented by VariableMapAdapter
      which bridges to VariablesState.
      **Status**: COMPLETE (mica)
    end note

    interface Function <<mica>> {
        + numParams : Int <<get>>
        + isFixedNumParams : Boolean <<get>>
        + eval(params: List<Any>, vMap: VariableMap) : Any
    }

    note right of Function
      **ink.kt** : Function.kt:1-8
      ----
      **mica** : parser function contract
      Implemented by Knot (when isFunction).
      **Status**: COMPLETE (mica)
    end note

    class VariableMapAdapter <<mica>> {
        ~ story : Story
        --
        + getValue(token: String) : Any
        - getValueId(id: String) : String
        - getKnotId(id: String) : String
        + hasValue(token: String) : Boolean
        + hasFunction(token: String) : Boolean
        + getFunction(token: String) : Function
        + hasGameObject(token: String) : Boolean
        + debugInfo() : String
    }

    note right of VariableMapAdapter
      **ink.kt** : VariableMapAdapter.kt:1-104
        implements VariableMap
        bridges parser to Story runtime
        getValue()                L:13
        hasValue()                L:66
        debugInfo()               L:94
      ----
      **mica** : adapter pattern
      **Status**: COMPLETE (mica)
    end note
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 11: COMMON RUNTIME INTERFACE (2026)
' ══════════════════════════════════════════════════════════════════════════════

package "9. Common Interface" #E0F7FA {

    interface InkRuntime <<new>> {
        + canContinue() : Boolean
        + continueStory() : String
        + continueMaximally() : String
        + currentText : String <<get>>
        + currentChoices : List<InkChoice> <<get>>
        + currentTags : List<String> <<get>>
        + chooseChoiceIndex(choiceIdx: Int)
        + hasError : Boolean <<get>>
        + hasWarning : Boolean <<get>>
        + currentErrors : List<String>? <<get>>
        + currentWarnings : List<String>? <<get>>
        + getGlobalTags() : List<String>?
        + tagsForContentAtPath(path: String) : List<String>?
        + getVariable(name: String) : Any?
        + setVariable(name: String, value: Any?)
        + isEnded : Boolean <<get>>
    }

    interface InkChoice <<new>> {
        + text : String <<get>>
        + index : Int <<get>>
    }

    note right of InkRuntime
      Common contract for ink runtimes.
      Both ink.kt.Story (compiled JSON)
      and ink.kt.mica.Story (parser)
      can implement this interface.
      Enables ink-proof conformance testing
      against both runtimes.
    end note
}

Story ..|> InkRuntime : <<pending>>

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 12: TESTS
' ══════════════════════════════════════════════════════════════════════════════

package "12. Tests" #FCE4EC {

    note as N_TESTS
      **ink.kt Test Suite — 35 files, 180+ @Test methods**
      ═══════════════════════════════════════════════════

      |= File |= Lines |= @Test |= Scope |
      | ChoiceTest.kt | ~80 | 5 | Choice parsing + selection |
      | ConditionalTest.kt | ~100 | 5 | Conditional/sequence evaluation |
      | DeclarationTest.kt | ~70 | 3 | VAR declarations |
      | DivertTest.kt | ~60 | 4 | Divert resolution |
      | ExpressionTest.kt | ~120 | 8 | Math expression evaluation |
      | ExternTest.kt | ~90 | 5 | External function binding |
      | FunctionTest.kt | ~80 | 5 | Ink function calls |
      | GatherTest.kt | ~60 | 4 | Gather point flow |
      | GlueTest.kt | ~40 | 3 | Glue joining |
      | IncludeTest.kt | ~50 | 3 | INCLUDE resolution |
      | KnotTest.kt | ~53 | 3 | Knot navigation |
      | SimpleJsonTest.kt | ~60 | 4 | JSON read/write |
      | StitchTest.kt | ~50 | 3 | Stitch navigation |
      | StopwatchTest.kt | ~40 | 3 | Timer precision |
      | VariableTextTest.kt | ~80 | 5 | Dynamic text |

      **Test Resources**: TestResources.kt
      ⚠️ NEEDS_KMP: has 5 java.* imports
      (java.io.File, java.net.URI, classLoader)

      **ink-proof bytecode tests**: InkProofTest.kt
      B001-B007+ bytecode conformance tests.

      **MCP integration tests** (20 files):
      BidiTddInkTest, ColabEngineTest,
      InkEditEngineTest, InkMdTableTest,
      McpRouterTest, McpToolsTest, etc.
    end note
}

' ══════════════════════════════════════════════════════════════════════════════
' SECTION 13: CROSS-REFERENCE (mica / JS / C# / Java)
' ══════════════════════════════════════════════════════════════════════════════

note as PROGRESS
  **ink.kt KMP Progress Tracker (2026-02-28)**
  ══════════════════════════════════════════════

  **Runtime Classes (from C#/Java/JS)**
  |= ink.kt class |= C# |= Java |= JS |= mica |= Status |
  | InkObject | RTObject | RTObject | InkObject | Content | ✅ +mica fields |
  | Container | Container | Container | Container | Container | ✅ +mica fields |
  | Story | Story | Story | Story | Story | ✅ +parser mode |
  | StoryState | StoryState | StoryState | StoryState | — | ✅ Complete |
  | CallStack | CallStack | CallStack | CallStack | — | ✅ +writeJson +InkThread |
  | InkFlow : Flow<InkObject> | Flow | Flow | Flow | — | ✅ **REACTIVE** (Flow<T> + EmittingList) |
  | Path | Path | Path | Path | — | ✅ Complete |
  | Pointer | Pointer | Pointer | Pointer | — | ✅ Complete |
  | SearchResult | SearchResult | SearchResult | SearchResult | — | ✅ Complete |
  | DebugMetadata | DebugMetadata | DebugMetadata | DebugMetadata | — | ✅ Complete |
  | Value<T> | Value<T> | AbstractValue | Value | Double | ✅ Complete |
  | Choice | Choice | Choice | Choice | Choice | ✅ +mica fields |
  | ChoicePoint | ChoicePoint | ChoicePoint | ChoicePoint | — | ✅ Complete |
  | Divert | Divert | Divert | Divert | Divert | ✅ +mica merge |
  | Tag | — | — | Tag | Tag | ✅ +mica merge |
  | Glue | Glue | Glue | Glue | — | ✅ Complete |
  | InkVoid | Void | Void | Void | — | ✅ Complete (renamed) |
  | ControlCommand | ControlCommand | ControlCommand | ControlCommand | — | ✅ Complete |
  | NativeFunctionCall | NativeFunctionCall | NativeFunctionCall | NativeFunctionCall | Expression | ✅ Complete |
  | VariableAssignment | VariableAssignment | VariableAssignment | VariableAssignment | Declaration | ✅ Complete |
  | VariableReference | VariableReference | VariableReference | VariableReference | — | ✅ Complete |
  | VariablesState | VariablesState | VariablesState | VariablesState | VariableMap | ✅ Complete |
  | StatePatch | StatePatch | StatePatch | StatePatch | — | ✅ Complete |
  | InkList | InkList | InkList | InkList | — | ✅ Complete |
  | InkListItem | InkListItem | InkListItem | InkListItem | — | ✅ Complete |
  | ListDefinition | ListDefinition | ListDefinition | ListDefinition | — | ✅ Complete |
  | ListDefinitionsOrigin | ListDefinitionsOrigin | ListDefinitionsOrigin | ListDefinitionsOrigin | — | ✅ Complete |
  | JsonSerialisation | Json | Json | JsonSerialisation | StoryLoader | ✅ Complete |
  | SimpleJson | SimpleJson | SimpleJson | SimpleJson | — | ✅ Complete |
  | Profiler | Profiler | Profiler | — | — | ✅ Complete |
  | ProfileNode | ProfileNode | ProfileNode | — | — | ✅ Complete |
  | Stopwatch | Stopwatch | Stopwatch | — | — | ✅ Complete |
  | StoryException | StoryException | StoryException | StoryException | — | ✅ Complete |

  **Parser Classes (from mica)**
  |= ink.kt class |= mica origin |= Status |
  | InkParser | InkParser | ✅ Ported |
  | Expression | Expression | ✅ Ported |
  | Knot | Knot | ✅ Ported |
  | Stitch | Stitch | ✅ Ported |
  | Gather | Gather | ✅ Ported |
  | Conditional | Conditional | ✅ Ported |
  | ConditionalOption | ConditionalOption | ✅ Ported |
  | Declaration | Declaration | ✅ Ported |
  | ParameterizedContainer | ParameterizedContainer | ✅ Ported |

  **Support Classes (from mica)**
  |= ink.kt class |= mica origin |= Status |
  | StoryText | StoryText | ✅ Ported |
  | Symbol | Symbol | ✅ Ported |
  | StoryJson | StoryJson | ✅ Ported |
  | Operator | Operator | ✅ Ported |
  | StoryWrapper | StoryWrapper | ✅ Ported |
  | StoryInterrupt | StoryInterrupt | ✅ Ported |
  | VariableMap | VariableMap | ✅ Ported |
  | Function | Function | ✅ Ported |
  | VariableMapAdapter | VariableMapAdapter | ✅ Ported |
  | StoryLoader | StoryLoader | ✅ Ported |
  | StorySaver | StorySaver | ✅ Ported |

  **Infra (Kotlin-only)**
  |= ink.kt class |= Note |= Status |
  | InkClock | KT-only clock | ✅ Complete |
  | DateComponents | KT-only data class | ✅ Complete |
  | InkRuntime | KT-only interface | ⬜ NEW |
  | InkChoice | KT-only interface | ⬜ NEW |

  **Totals: 56 classes in PUML (was 45)**
  **mica KMP port**: ✅ All 6 JVM deps replaced
  **Parser fields**: ✅ Merged into InkObject, Container, Choice, Story
  **Ink prefix renames**: Flow→InkFlow, Void→InkVoid, Thread→InkThread
  **State serialization**: ✅ All gaps resolved (~555 LOC added)
  **Reactive streams**: ✅ InkFlow implements Flow<InkObject> (MutableSharedFlow)
  **ink-proof e2e**: 7 bytecode + 135 ink tests
  **Next**: Move 22 non-colliding mica classes to ink.kt package

  **Architecture: code-first three layers**
  ink.model → ink.kt → ink.kt.services

  **Multi-tenant MMO architecture:**
  Compiled Container (shared) → N × Story (per session)
  Each Story → StoryState → InkFlow(s) → Flow<InkObject>
  InkThread = coroutine (cooperative on JS, parallel on JVM)
  EmittingList bridges sync engine → reactive stream
end note

note as GAPS
  **Cross-Implementation Gap Analysis (2026-02-28)**
  ════════════════════════════════════════════════════

  **1. Remaining Gaps — ALL RESOLVED**

  | Class | Gap | LOC | Status |
  | ~~StoryState~~ | ~~toJson(), loadJson(), writeJson(), loadJsonObj(), visitCountAtPathString()~~ | ~340 | ✅ Done |
  | ~~JsonSerialisation~~ | ~~encodeFlow → InkFlow.writeJson, encodeThread → InkThread.writeJson~~ | ~80 | ✅ Done |
  | ~~InkList~~ | ~~InkList(name,Story), singleOriginListName, addItem(name,story), contains(String)~~ | ~30 | ✅ Done |
  | ~~Story~~ | ~~toJson(Appendable) stream overload~~ | ~5 | ✅ Done |
  | ~~VariablesState~~ | ~~writeJson(writer)~~ | ~20 | ✅ Done |
  | ~~CallStack~~ | ~~writeJson(writer), InkThread.writeJson(writer)~~ | ~40 | ✅ Done |
  | ~~InkFlow~~ | ~~writeJson(writer)~~ | ~40 | ✅ Done |

  **2. mica → ink.kt merge status**

  | Feature | mica | ink.kt | Status |
  | Parser fields (4 colliding) | ✅ merged | ✅ InkObject/Container/Choice/Story | ✅ Done |
  | 22 non-colliding classes | ✅ in ink.kt | ⬜ move to ink.kt package | NEXT |
  | Delete mica/ directory | — | ⬜ after move | NEXT |

  **3. mica KMP porting (JVM → KMP) — ✅ ALL COMPLETE**

  | JVM Dependency | KMP Replacement | Status |
  | BigDecimal | Double | ✅ |
  | java.io.InputStream | String input | ✅ |
  | Jackson JsonParser | kotlinx.serialization.json | ✅ |
  | Jackson JsonGenerator | kotlinx.serialization.json | ✅ |
  | Java reflection | GameObjectResolver fun interface | ✅ |
  | MathContext/RoundingMode | kotlin.math.pow | ✅ |

  **4. C# → ink.kt (all ported except stream overloads)**

  | Feature | C# | ink.kt | Note |
  | ContinueAsync | ✅ | ✅ | Ported |
  | Stream overloads | ✅ | ✅ | toJson(Appendable) |
  | All callbacks | ✅ delegate | ✅ fun interface | Idiomatic |
  | Copy/dontSaveDefaultValues | ✅ | ✅ | Ported |

  **5. ink.kt unique (not in C#/Java/JS)**

  | Feature | Note |
  | InkClock | KMP pluggable clock |
  | DateComponents | Clock decomposition |
  | sealed class Value | Exhaustive when() |
  | fun interface SAM | Lambda-friendly API |
  | InkRuntime interface | Common runtime contract |
  | Parser mode (mica) | .ink file parsing |

  **6. Merge priority**

  | # | Task | Status |
  | 1 | ~~Event callbacks~~ | ✅ Done |
  | 2 | ~~mica KMP port~~ | ✅ Done |
  | 3 | ~~Parser fields merge~~ | ✅ Done |
  | 4 | ~~ContinueSingleStep~~ | ✅ Done |
  | 5 | ~~State serialization (~300 LOC)~~ | ✅ Done |
  | 6 | ~~InkList completeness (~30 LOC)~~ | ✅ Done |
  | 7 | Move 22 mica classes | Phase 6e |
  | 8 | Delete mica/ directory | Phase 6f |
  | 9 | KT/KMP compiler | FUTURE |
end note

PROGRESS .. Story
GAPS .. InkRuntime

' ══════════════════════════════════════════════════════════════════════════════
' SECTION: CAMEL ROUTES + RSOCKET + MCP INTEGRATION
' ══════════════════════════════════════════════════════════════════════════════

note as N_CAMEL_RSOCKET_MCP
  **Camel Routes ↔ RSocket ↔ MCP Tools ↔ Ink API — Integration Architecture**
  ═══════════════════════════════════════════════════════════════════════════════

  **1. Three Protocol Layers**

  | Layer | Transport | Encoding | Pattern | Kotlin concurrency |
  | MCP | SSE + POST (Ktor) | JSON-RPC | request-response | Channel<ServerSentEvent> |
  | Yjs | WebSocket /collab/:docId | Y.Doc binary | CRDT sync | launch { send(frame) } |
  | RSocket | WebSocket /rsocket | msgpack | stream / fire-and-forget | launch { send(frame) } |

  **2. Camel Routes (10 routes, direct: only)**

  CamelRoutes.kt uses Apache Camel 4.18 with ""direct:"" endpoints.
  No network transport, no message brokers — all in-process.

  | Route | Endpoint | Engine | Purpose |
  | llm-chat | direct:llm-chat | LlmEngine.chat() | Chat with loaded LLM |
  | llm-langchain4j | direct:llm-langchain4j | langchain4j-chat:inky | Camel LangChain4j component |
  | llm-generate-ink | direct:llm-generate-ink | LlmEngine.generateInk() | NL → ink code |
  | llm-review-ink | direct:llm-review-ink | LlmEngine.reviewInk() | Code review |
  | llm-translate-he | direct:llm-translate-he | LlmEngine.translateToHebrew() | DictaLM Hebrew |
  | ink-compile | direct:ink-compile | InkEngine.compile() | Compile .ink source |
  | ink-play | direct:ink-play | InkEngine.startSession() | Start story session |
  | ink-choose | direct:ink-choose | InkEngine.choose() | Make choice (headers) |
  | llm-compile-chain | direct:llm-compile-chain | Pipeline | generate → compile → play |
  | ink-asset-event | direct:ink-asset-event | AssetEventEngine | Tags → asset events |
  | voice-synthesize | direct:voice-synthesize | AssetEventEngine | Voice synthesis request |

  **3. Camel ↔ MCP Tools dispatch**

  ""McpTools"" invokes Camel via:
    ""camelRoutes.sendToRoute(routeName, body, headers)""
    → ProducerTemplate.requestBodyAndHeaders(""direct:$routeName"", body, headers)

  LLM tool priority: external service → Camel route → LlmEngine direct.

  **4. Camel ↔ Ink API ↔ RSocket event flow**

  ""direct:llm-compile-chain"" (full pipeline):
    prompt → ""direct:llm-generate-ink"" (LlmEngine)
           → ""direct:ink-compile"" (InkEngine.compile)
           → choice(success?) → ""direct:ink-play"" (InkEngine.startSession)
                               → ContinueResult { text, tags, choices }

  ""direct:ink-asset-event"" (tags → asset pipeline):
    tags[] → AssetEventEngine.processStoryState(sessionId, tags, knot)
           → EmojiAssetManifest.parseInkTags(tags)
           → AssetEventBus.publish(""ink/story/tags"", InkTagEvent)
           → AssetEventBus.publish(""ink/asset/load"", AssetLoadRequest) [per asset]
           ← WebSocket /rsocket subscribers receive msgpack frames

  **5. RSocket WebSocket protocol (/rsocket)**

  Client → Server (msgpack binary frames):
    | type | fields | handler |
    | ""subscribe"" | session_id, channels[] | bus.subscribe() + replay |
    | ""fire_and_forget"" | channel, data | bus.publish() |
    | ""request"" | channel, limit | bus.recentEvents() |

  Server → Client (msgpack binary frames):
    ""{ channel, event, timestamp [, replay: true] }""

  6 channels (AsyncAPI ink-asset-events.yaml):
    ""ink/story/tags""        → InkTagEvent (server → client)
    ""ink/asset/load""        → AssetLoadRequest (server → client)
    ""ink/asset/loaded""      → AssetLoadedEvent (client → server)
    ""ink/inventory/change""  → InventoryChangeEvent (server → client)
    ""ink/voice/synthesize""  → VoiceSynthRequest (server → client)
    ""ink/voice/ready""       → VoiceReadyEvent (client → server)

  **6. Flow of data through all three protocols**

  LLM Agent (Claude/GPT)
    ↓ MCP JSON-RPC: tools/call generate_compile_play
  McpTools
    ↓ camelRoutes.sendToRoute(""llm-compile-chain"", prompt)
  Camel direct:llm-generate-ink → direct:ink-compile → direct:ink-play
    ↓ ContinueResult { text, tags: [""# anim:slash"", ""# mesh:sword""] }
  McpTools (or Camel direct:ink-asset-event)
    ↓ assetEventEngine.processStoryState(sessionId, tags, knot)
  AssetEventBus.publish(""ink/story/tags"", InkTagEvent)
  AssetEventBus.publish(""ink/asset/load"", AssetLoadRequest)
    ↓ bus subscriber callbacks
  /rsocket WebSocket handler
    ↓ launch { send(Frame.Binary(msgpack)) }
  Browser (BabylonJS) / Electron / Unity (OneJS)
    ↓ SceneLoader.ImportMesh(glTF) / AnimationGroup.start()
  Client confirms: fire_and_forget → ""ink/asset/loaded""

  **7. Camel EIP patterns in use**

  | Pattern | Where | Example |
  | Content-Based Router | llm-langchain4j | choice().when(bean:isLoaded) |
  | Pipeline | llm-compile-chain | generate → compile → play |
  | Wire Tap | ink-asset-event | Tags → side-channel to asset bus |
  | Processor | All routes | process { exchange → engine.call() } |
  | Registry Binding | start() | ctx.registry.bind(""inkEngine"", engine) |

  **8. Kotlin Flow ↔ Camel bridge points**

  InkFlow (reactive) and Camel (imperative) meet at these boundaries:
    • **InkFlow → Camel**: Not direct. InkEngine.continueStory() is synchronous;
      results passed to Camel processors as exchange body.
    • **Camel → AssetEventBus → RSocket WS**: Camel route calls
      assetEventEngine → bus.publish() → subscriber callback → launch { send() }.
    • **Potential**: ""camel-reactive-streams"" could bridge Flow<InkObject>
      to Camel routes via ReactiveStreamsHelper.toPublisher().
      Not currently used — Camel routes are all synchronous direct: hops.

  **9. Build dependencies (Camel + RSocket)**

  Apache Camel 4.18:
    camel-core, camel-main, camel-direct
    camel-langchain4j-chat, camel-langchain4j-tools
    camel-jackson
  RSocket-Kotlin 0.16.0:
    rsocket-ktor-server, rsocket-ktor-client
  msgpack: jackson-dataformat-msgpack 0.9.8
  Note: /rsocket endpoint is hand-rolled msgpack-over-WS,
  not the actual RSocket wire protocol (despite dependency).
end note

N_CAMEL_RSOCKET_MCP .. GAPS

' ══════════════════════════════════════════════════════════════════════════════
' LEGEND
' ══════════════════════════════════════════════════════════════════════════════

legend bottom right
  |= Color |= Meaning |
  | <#E3F2FD> | Kotlin class (ink.kt package) |
  | <#E8F5E9> | Interface / fun interface |
  | <#FFF3E0> | Enum class |
  | <#F3E5F5> | Object singleton |
  | <#ECEFF1> | Infrastructure / utilities |
  | <#E0F7FA> | Common interface (new) |
  |= Symbol |= Meaning |
  | --|> | Inheritance (extends / sealed) |
  | ..|> | Interface implementation |
  | *--> | Composition (owns) |
  | --> | Association (references) |
  | +-- | Nested class ownership |
  | ..> | Dependency (uses) |
  |= Status |= Meaning |
  | ✅ | Complete in ink.kt |
  | ⬜ | Pending / new |
endlegend

@enduml
