@startuml ink.kt.mica – Parser-Based Ink Runtime (Reference)

' ==============================================================================
' ink.kt.mica — Parser-Based Ink Runtime Reference Implementation
' Package: ink.kt.mica
' Source:  ink-kmp-mcp/src/commonMain/kotlin/ink/kt/mica/
'
' Ported from mica-ink (Java) → idiomatic Kotlin.
' Parses .ink files at runtime (no compiler needed).
' Reference for building ink.kt parser capabilities.
'
' Last updated: 2026-02-27
' ==============================================================================

skinparam backgroundColor #FAFAFA
skinparam shadowing false
skinparam roundcorner 8

skinparam class {
    BackgroundColor #FFF3E0
    BorderColor #E65100
    HeaderBackgroundColor #F57C00
    FontColor #212121
    FontName JetBrains Mono
    FontSize 11
    HeaderFontColor #FFFFFF
    HeaderFontSize 12
    AttributeFontSize 10
    StereotypeFontSize 9
}

skinparam interface {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
    HeaderBackgroundColor #388E3C
    FontColor #212121
    HeaderFontColor #FFFFFF
    FontSize 11
}

skinparam object {
    BackgroundColor #F3E5F5
    BorderColor #6A1B9A
    HeaderBackgroundColor #7B1FA2
    FontColor #212121
    HeaderFontColor #FFFFFF
    FontSize 11
}

skinparam note {
    BackgroundColor #FFFDE7
    BorderColor #F9A825
    FontSize 10
    FontName JetBrains Mono
}

title ink.kt.mica — Parser-Based Ink Runtime\n(Reference for ink.kt KMP port)
footer ink.kt.mica | ported from mica-ink (Java) | parses .ink at runtime | 28 files ~2100 LOC

' ═══════════════════════════════════════════════════════════
' CORE HIERARCHY
' ═══════════════════════════════════════════════════════════

package "Core" #FFF3E0 {

    class Content <<open>> {
        + id : String
        + text : String
        + parent : Container?
        + lineNumber : Int
        ~ count : Int
        --
        + getText(story: Story) : String
        .. companion ..
        {static} getId(parent: Container) : String
    }

    class Container <<open>> {
        ~ index : Int
        ~ children : MutableList<Content>
        --
        + add(item: Content)
        + get(i: Int) : Content
        + indexOf(c: Content) : Int
        + size : Int <<get>>
    }

    class ParameterizedContainer <<open>> {
        + parameters : List<String>
        ~ values : MutableMap<String, Any>
        --
        + hasValue(key: String) : Boolean
        + getValue(key: String) : Any
        + setValue(key: String, value: Any)
        .. companion ..
        {static} getParameters(header: String) : List<String>
    }

    Content <|-- Container
    Container <|-- ParameterizedContainer
}

' ═══════════════════════════════════════════════════════════
' AST NODES (parser-specific — not in ink.kt)
' ═══════════════════════════════════════════════════════════

package "AST Nodes" #FFECB3 {

    class Knot {
        ~ isFunction : Boolean
        --
        + eval(params, vMap) : Any
        .. companion ..
        {static} isKnot(str) : Boolean
        {static} getId(id) : String
        {static} isFunction(id) : Boolean
    }

    class Stitch {
        .. companion ..
        {static} isStitchHeader(str) : Boolean
        {static} getId(header, parent) : String
        {static} getParent(container) : Container
    }

    class Choice {
        + level : Int
        - conditions : MutableList<String>
        - repeatable : Boolean
        --
        + isFallBack() : Boolean
        + evaluateConditions(story) : Boolean
        .. companion ..
        {static} getChoiceDepth(line) : Int
        {static} getId(header, parent) : String
        {static} extractChoiceText(header) : String
        {static} getParent(container, lvl) : Container
    }

    class Gather {
        + level : Int
        .. companion ..
        {static} getChoiceDepth(line) : Int
        {static} getId(text, parent) : String
        {static} getParent(container, lvl) : Container
    }

    class Conditional {
        - seqType : SequenceType
        --
        + resolveConditional(story) : Container
        .. companion ..
        {static} isConditionalHeader(str) : Boolean
    }

    class ConditionalOption {
        + evaluate(vMap) : Boolean
        .. companion ..
        {static} getCondition(txt) : String
    }

    class Declaration {
        - isDeclaration : Boolean
        --
        + evaluate(story: Story)
        .. companion ..
        {static} evaluate(str, variables) : Any
        {static} isVariableHeader(str) : Boolean
    }

    class Divert {
        + resolveDivert(story) : Container
    }

    class Tag {
    }

    ParameterizedContainer <|-- Knot
    ParameterizedContainer <|-- Stitch
    Container <|-- Choice
    Container <|-- Gather
    Container <|-- Conditional
    Container <|-- ConditionalOption
    Content <|-- Declaration
    Content <|-- Divert
    Content <|-- Tag
}

' ═══════════════════════════════════════════════════════════
' EXPRESSION EVALUATOR
' ═══════════════════════════════════════════════════════════

package "Expression" #E1F5FE {

    class Expression {
        - mc : MathContext
        - rpn : List<String>?
        - operators : SortedMap<String, Operator>
        - expression : String
        --
        + eval(vMap: VariableMap) : Any
        + setPrecision(precision: Int) : Expression
        + setRoundingMode(mode) : Expression
        .. companion ..
        {static} PI : BigDecimal
        {static} e : BigDecimal
        {static} isNumber(st: String) : Boolean
    }

    abstract class Operator {
        + oper : String
        + precedence : Int
        + isLeftAssoc : Boolean
        --
        {abstract} + eval(v1: Any, v2: Any) : Any
    }

    Expression --> "*" Operator : operators
}

' ═══════════════════════════════════════════════════════════
' RUNTIME
' ═══════════════════════════════════════════════════════════

package "Runtime" #E8F5E9 {

    class Story <<VariableMap>> {
        ~ wrapper : StoryWrapper
        ~ container : Container
        ~ content : MutableMap<String, Content>
        ~ fileNames : MutableList<String>
        ~ variables : MutableMap<String, Any>
        ~ text : MutableList<String>
        ~ choices : MutableList<Container>
        - functions : SortedMap<String, Function>
        - interrupts : MutableList<StoryInterrupt>
        --
        + next() : List<String>
        + choose(idx: Int)
        + choiceSize : Int <<get>>
        + choiceText(i: Int) : String
        + putVariable(key, value)
        + putVariables(map)
        + isEnded : Boolean <<get>>
        + setContainer(s: String)
        + resolveInterrupt(divert) : String
        + getDivert(d) : Container
        + add(story: Story)
        + clear()
        + contains(s: String) : Boolean
        .. VariableMap impl ..
        + logException(e)
        + hasValue(token) : Boolean
        + getValue(token) : Any
        + hasFunction(token) : Boolean
        + getFunction(token) : Function
        + hasGameObject(token) : Boolean
        + debugInfo() : String
    }

    interface VariableMap {
        + logException(e: Exception)
        + hasValue(token: String) : Boolean
        + getValue(token: String) : Any
        + hasFunction(token: String) : Boolean
        + getFunction(token: String) : Function
        + hasGameObject(token: String) : Boolean
        + debugInfo() : String
    }

    interface Function {
        + numParams : Int
        + isFixedNumParams : Boolean
        + eval(params, vMap) : Any
    }

    Story ..|> VariableMap
    Knot ..|> Function
}

' ═══════════════════════════════════════════════════════════
' PARSER + SERIALIZATION
' ═══════════════════════════════════════════════════════════

package "Parser" #F3E5F5 {

    object InkParser {
        + parse(provider, fileName) : Story
        + parse(inputStream, provider, fileName) : Story
        ~ parseDivert(lineNumber, line, container) : List<Content>
    }

    interface StoryWrapper {
        + getStream(fileId) : InputStream
        + getStoryObject(objId) : Any
        + getInterrupt(s) : StoryInterrupt
        + resolveTag(t: String)
        + logDebug(m: String)
        + logError(m: String)
        + logException(e: Exception)
    }

    abstract class StoryInterrupt {
        + id : String
        + text : String
        + condition : String
        + file : String
        + isChoice : Boolean
        + isDivert : Boolean
        + isActive : Boolean
    }

    object StoryLoader {
        + loadStream(p: JsonParser, story: Story)
    }

    object StorySaver {
        + saveStream(g: JsonGenerator, story: Story)
    }

    object StoryText {
        + getText(text, count, variables) : String
    }

    object Symbol {
        + CBRACE_LEFT/RIGHT : Char
        ~ DIVERT, GLUE, DOT : String
        ~ CHOICE_DOT/PLUS, DASH : Char
        ~ HEADER, COMMENT : Char/String
        .. (30+ constants) ..
    }

    object StoryJson {
        + FILE, FILES, CONTENT : String
        + COUNT, VARIABLES : String
        + CONTAINER, TEXT, CHOICES : String
        .. (14 constants) ..
    }
}

' ═══════════════════════════════════════════════════════════
' EXCEPTIONS
' ═══════════════════════════════════════════════════════════

package "Exceptions" #FFEBEE {
    class InkRunTimeException
    class InkParseException
    class InkLoadingException
}

' ═══════════════════════════════════════════════════════════
' RELATIONSHIPS
' ═══════════════════════════════════════════════════════════

InkParser --> Story : creates
InkParser --> StoryWrapper : uses
Story --> StoryWrapper : wrapper
Story --> "*" StoryInterrupt : interrupts
Story --> StoryText : text evaluation
StoryLoader --> Story : loads state into
StorySaver --> Story : saves state from
Expression --> VariableMap : evaluates against

' ═══════════════════════════════════════════════════════════
' COMPARISON NOTES
' ═══════════════════════════════════════════════════════════

note as N1
  **ink.kt.mica vs ink.kt Architecture Comparison**
  ════════════════════════════════════════════════

  **mica** (parser-based):
  - Parses .ink source files at runtime
  - Tree traversal with container.index pointer
  - BigDecimal-only values
  - Expression evaluator (EvalEx-based)
  - 28 classes, ~2100 LOC

  **ink.kt** (compiled runtime):
  - Loads pre-compiled JSON bytecode
  - CallStack + evaluation stack (VM-style)
  - Sealed Value hierarchy (Bool/Int/Float/String/List)
  - NativeFunctionCall operator dispatch
  - 36 classes, ~8000+ LOC

  **Unique to mica (candidates for ink.kt)**:
  ✅ InkParser — parse .ink at runtime
  ✅ Expression — standalone expression evaluator
  ✅ Symbol — ink syntax constants
  ✅ StoryInterrupt — conditional flow override

  **Unique to ink.kt (mature runtime)**:
  ✅ CallStack + Thread — proper scope management
  ✅ Path + Pointer — structured navigation
  ✅ Flow — named execution contexts
  ✅ Profiler — instruction-level profiling
  ✅ SimpleJson — zero-dep JSON parser
end note

note as N2
  **ink-proof conformance (2026)**
  ══════════════════════════════
  Test resources:
  - 7 bytecode tests (B001-B007)
  - 135 ink tests (I001-I135)

  ink.kt can run bytecode tests directly.
  mica can run ink tests directly (with StoryWrapper).
  Both implement InkRuntime interface.
end note

N1 .. Story
N2 .. InkParser

legend bottom right
  |= Color |= Meaning |
  | <#FFF3E0> | mica class (parser-based) |
  | <#E8F5E9> | Interface |
  | <#F3E5F5> | Object singleton |
  | <#FFECB3> | AST node (parser-specific) |
  | <#E1F5FE> | Expression evaluator |
  | <#FFEBEE> | Exception classes |
  |= Status |= Meaning |
  | ✅ | Complete / portable to ink.kt |
  | ⬜ | Pending / needs work |
endlegend

@enduml
