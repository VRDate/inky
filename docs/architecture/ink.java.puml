@startuml ink-java-blade-ink

' =============================================================================
' PlantUML Class Diagram: blade-ink Java Runtime
' Package: com.bladecoder.ink.runtime
' Source:  ink-kmp-mcp/src/jvmMain/java/com/bladecoder/ink/runtime/
' =============================================================================

title **blade-ink Java Runtime** -- com.bladecoder.ink.runtime\nClass Diagram (46 source files)

' -- Skin / Theme ---------------------------------------------------------
skinparam backgroundColor #FFFDF5
skinparam classBorderColor #B8860B
skinparam classBackgroundColor #FFF3CD
skinparam classHeaderBackgroundColor #FFD966
skinparam classFontColor #3D2B00
skinparam classFontSize 11
skinparam classAttributeFontSize 10
skinparam classStereotypeFontColor #8B6914
skinparam arrowColor #B8860B
skinparam packageBorderColor #DAA520
skinparam packageBackgroundColor #FFFAEB
skinparam packageFontColor #8B6914
skinparam packageFontSize 13
skinparam noteBorderColor #DAA520
skinparam noteBackgroundColor #FFF8DC
skinparam noteFontSize 10
skinparam groupInheritance 2

' -- Legend / Notes --------------------------------------------------------
note as N1
  **Java (blade-ink) -> Kotlin (ink.kt) migration notes**
  ----
  | **Java blade-ink** | **Kotlin ink.kt** |
  | RTObject | InkObject |
  | AbstractValue + 8 value files | consolidated Value.kt |
  | Json | JsonSerialisation |
  | Error.ErrorType enum | ErrorType top-level enum |
  | StringExt | replaced by Kotlin stdlib |
  | ProfileNode (separate file) | combined into Profiler.kt |
  | SimpleJson.Reader / Writer | kotlinx.serialization.json reader / SimpleJson.Writer |
  ----
  C# ink-csharp is the canonical reference implementation.
  blade-ink is a faithful Java port by bladecoder (Rafael Garcia).
  ink.kt (this project) is a Kotlin Multiplatform port of blade-ink.
  ----
  **Compiler strategy (all 3 → identical JSON output)**
  | Compiler | Role |
  | C# inklecate | UNCHANGED — reference compiler, test oracle |
  | Java blade-ink | UNCHANGED — reference compiler, test oracle |
  | KT/KMP ink.kt | NEW compiler, validated against C# + Java JSON |
  ----
  **Code-first three-layer architecture**
  1. **ink.model** — Kotlin data classes + annotations → proto, OpenAPI, MCP, AsyncAPI
  2. **ink.kt** — Runtime classes (extend ink.model data classes)
  3. **ink.kt.services** — Companion objects per data class (ink language logic)
end note


' =========================================================================
' 1. CORE
' =========================================================================
package "Core" <<Rectangle>> {

  class RTObject {
    - parent : Container
    - path : Path
    - debugMetadata : DebugMetadata
    --
    + getParent() : Container
    + setParent(Container) : void
    + getPath() : Path
    + getDebugMetadata() : DebugMetadata
    + setDebugMetadata(DebugMetadata) : void
    + resolvePath(Path) : SearchResult
    + convertPathToRelative(Path) : Path
    + compactPathString(Path) : String
    + getRootContentContainer() : Container
    + debugLineNumberOfPath(Path) : Integer
    + copy() : RTObject
  }

  class Container {
    - name : String
    - content : List<RTObject>
    - namedContent : HashMap<String, INamedContent>
    - visitsShouldBeCounted : boolean
    - turnIndexShouldBeCounted : boolean
    - countingAtStartOnly : boolean
    --
    + getName() : String
    + getContent() : List<RTObject>
    + getNamedContent() : HashMap<String, INamedContent>
    + getCountFlags() : int
    + setCountFlags(int) : void
    + addContent(RTObject) : void
    + insertContent(RTObject, int) : void
    + contentAtPath(Path) : SearchResult
    + contentAtPath(Path, int, int) : SearchResult
    + buildStringOfHierarchy() : String
    + hasValidName() : boolean
  }

  class Path {
    - components : List<Component>
    - isRelative : boolean
    - componentsString : String
    --
    + getComponent(int) : Component
    + isRelative() : boolean
    + getHead() : Component
    + getTail() : Path
    + getLength() : int
    + getLastComponent() : Component
    + containsNamedComponent() : boolean
    + pathByAppendingPath(Path) : Path
    + pathByAppendingComponent(Component) : Path
    + getComponentsString() : String
    + {static} getSelf() : Path
    + equals(Path) : boolean
  }

  class "Path.Component" as PathComponent {
    - index : int
    - name : String
    --
    + getIndex() : int
    + getName() : String
    + isIndex() : boolean
    + isParent() : boolean
    + {static} toParent() : Component
  }

  class SearchResult {
    + obj : RTObject
    + approximate : boolean
    --
    + correctObj() : RTObject
    + getContainer() : Container
  }

  class Pointer {
    + container : Container
    + index : int
    --
    + assign(Pointer) : void
    + resolve() : RTObject
    + isNull() : boolean
    + getPath() : Path
    + {static} startOf(Container) : Pointer
    + {static} Null : Pointer
  }

  class DebugMetadata {
    + startLineNumber : int
    + endLineNumber : int
    + startCharacterNumber : int
    + endCharacterNumber : int
    + fileName : String
    + sourceName : String
    --
    + merge(DebugMetadata) : DebugMetadata
  }
}


' =========================================================================
' 2. CONTENT
' =========================================================================
package "Content" <<Rectangle>> {

  class ChoicePoint {
    - hasChoiceOnlyContent : boolean
    - hasStartContent : boolean
    - isInvisibleDefault : boolean
    - onceOnly : boolean
    - hasCondition : boolean
    - pathOnChoice : Path
    --
    + getChoiceTarget() : Container
    + getFlags() : int
    + setFlags(int) : void
    + getPathOnChoice() : Path
    + getPathStringOnChoice() : String
    + isOnceOnly() : boolean
    + hasCondition() : boolean
  }

  class Choice {
    ~ targetPath : Path
    ~ isInvisibleDefault : boolean
    ~ tags : List<String>
    ~ originalThreadIndex : int
    ~ sourcePath : String
    - index : int
    - text : String
    - threadAtGeneration : CallStack.Thread
    --
    + getIndex() : int
    + getText() : String
    + getTags() : List<String>
    + getPathStringOnChoice() : String
    + getThreadAtGeneration() : CallStack.Thread
    + clone() : Choice
  }

  class Divert {
    - externalArgs : int
    - isConditional : boolean
    - isExternal : boolean
    - pushesToStack : boolean
    - stackPushType : PushPopType
    - targetPointer : Pointer
    - targetPath : Path
    - variableDivertName : String
    --
    + getTargetPath() : Path
    + getTargetPathString() : String
    + getTargetPointer() : Pointer
    + getVariableDivertName() : String
    + hasVariableTarget() : boolean
    + isConditional() : boolean
    + isExternal() : boolean
    + getPushesToStack() : boolean
    + getStackPushType() : PushPopType
  }

  class Glue {
  }

  class Tag {
    - text : String
    --
    + getText() : String
  }

  class Void {
  }

  class ControlCommand {
    - commandType : CommandType
    --
    + getCommandType() : CommandType
    + setCommandType(CommandType) : void
    + copy() : RTObject
  }

  enum "ControlCommand.CommandType" as CommandType {
    NotSet
    EvalStart
    EvalOutput
    EvalEnd
    Duplicate
    PopEvaluatedValue
    PopFunction
    PopTunnel
    BeginString
    EndString
    NoOp
    ChoiceCount
    Turns
    TurnsSince
    ReadCount
    Random
    SeedRandom
    VisitIndex
    SequenceShuffleIndex
    StartThread
    Done
    End
    ListFromInt
    ListRange
    ListRandom
    BeginTag
    EndTag
  }

  class VariableAssignment {
    - isGlobal : boolean
    - isNewDeclaration : boolean
    - variableName : String
    --
    + getVariableName() : String
    + isGlobal() : boolean
    + isNewDeclaration() : boolean
  }

  class VariableReference {
    - name : String
    - pathForCount : Path
    --
    + getName() : String
    + getPathForCount() : Path
    + getPathStringForCount() : String
    + getContainerForCount() : Container
  }

  class NativeFunctionCall {
    - name : String
    - numberOfParameters : int
    - isPrototype : boolean
    - operationFuncs : HashMap<ValueType, Object>
    - prototype : NativeFunctionCall
    --
    + getName() : String
    + getNumberOfParameters() : int
    + call(List<RTObject>) : RTObject
    + {static} callExistsWithName(String) : boolean
    + {static} callWithName(String) : NativeFunctionCall
    .. operator constants ..
    + {static} Add : String = "+"
    + {static} Subtract : String = "-"
    + {static} Multiply : String = "*"
    + {static} Divide : String = "/"
    + {static} Mod : String = "%"
    + {static} Negate : String = "_"
    + {static} Equal : String = "=="
    + {static} NotEquals : String = "!="
    + {static} Greater : String = ">"
    + {static} Less : String = "<"
    + {static} And : String = "&&"
    + {static} Or : String = "||"
    + {static} Not : String = "!"
    + {static} Min : String = "MIN"
    + {static} Max : String = "MAX"
    + {static} Pow : String = "POW"
    + {static} Floor : String = "FLOOR"
    + {static} Ceiling : String = "CEILING"
    + {static} Int : String = "INT"
    + {static} Float : String = "FLOAT"
    + {static} Has : String = "?"
    + {static} Hasnt : String = "!?"
    + {static} Intersect : String = "^"
    + {static} ListMin : String = "LIST_MIN"
    + {static} ListMax : String = "LIST_MAX"
    + {static} All : String = "LIST_ALL"
    + {static} Count : String = "LIST_COUNT"
    + {static} ValueOfList : String = "LIST_VALUE"
    + {static} Invert : String = "LIST_INVERT"
  }
}


' =========================================================================
' 3. VALUES
' =========================================================================
package "Values" <<Rectangle>> {

  abstract class AbstractValue {
    + {abstract} getValueType() : ValueType
    + {abstract} isTruthy() : boolean
    + {abstract} cast(ValueType) : AbstractValue
    + {abstract} getValueObject() : Object
    + {static} create(Object) : AbstractValue
    + copy() : RTObject
    # BadCastException(ValueType) : StoryException
  }

  abstract class "Value<T>" as Value_T {
    # value : T
    --
    + getValue() : T
    + setValue(T) : void
    + getValueObject() : Object
  }

  class BoolValue {
    + getValueType() : ValueType  ' Bool
    + isTruthy() : boolean
    + cast(ValueType) : AbstractValue
  }

  class IntValue {
    + getValueType() : ValueType  ' Int
    + isTruthy() : boolean
    + cast(ValueType) : AbstractValue
  }

  class FloatValue {
    + getValueType() : ValueType  ' Float
    + isTruthy() : boolean
    + cast(ValueType) : AbstractValue
  }

  class StringValue {
    - isInlineWhitespace : boolean
    - isNewline : boolean
    --
    + getValueType() : ValueType  ' String
    + isTruthy() : boolean
    + cast(ValueType) : AbstractValue
    + isInlineWhitespace() : boolean
    + isNewline() : boolean
    + isNonWhitespace() : boolean
  }

  class DivertTargetValue {
    + getValueType() : ValueType  ' DivertTarget
    + getTargetPath() : Path
    + setTargetPath(Path) : void
    + isTruthy() : boolean
    + cast(ValueType) : AbstractValue
  }

  class VariablePointerValue {
    - contextIndex : int
    --
    + getValueType() : ValueType  ' VariablePointer
    + getVariableName() : String
    + getContextIndex() : int
    + isTruthy() : boolean
    + cast(ValueType) : AbstractValue
    + copy() : RTObject
  }

  class ListValue {
    + getValueType() : ValueType  ' List
    + isTruthy() : boolean
    + cast(ValueType) : AbstractValue
    + {static} retainListOriginsForAssignment(RTObject, RTObject) : void
  }

  enum ValueType {
    Bool
    Int
    Float
    List
    String
    DivertTarget
    VariablePointer
  }
}


' =========================================================================
' 4. LISTS
' =========================================================================
package "Lists" <<Rectangle>> {

  class InkList << HashMap<InkListItem, Integer> >> {
    - origins : List<ListDefinition>
    - originNames : List<String>
    --
    + getOrigins() : List<ListDefinition>
    + getOriginNames() : List<String>
    + setInitialOriginName(String) : void
    + setInitialOriginNames(List<String>) : void
    + union(InkList) : InkList
    + without(InkList) : InkList
    + intersect(InkList) : InkList
    + hasIntersection(InkList) : boolean
    + getMaxItem() : Entry<InkListItem, Integer>
    + getMinItem() : Entry<InkListItem, Integer>
    + contains(InkList) : boolean
    + contains(String) : boolean
    + greaterThan(InkList) : boolean
    + greaterThanOrEquals(InkList) : boolean
    + lessThan(InkList) : boolean
    + lessThanOrEquals(InkList) : boolean
    + maxAsList() : InkList
    + minAsList() : InkList
    + getInverse() : InkList
    + getAll() : InkList
    + addItem(InkListItem) : void
    + addItem(String) : void
    + containsItemNamed(String) : boolean
    + listWithSubRange(Object, Object) : InkList
    + {static} fromString(String, Story) : InkList
  }

  class InkListItem {
    - originName : String
    - itemName : String
    --
    + getOriginName() : String
    + getItemName() : String
    + getFullName() : String
    ~ isNull() : boolean
    + {static} getNull() : InkListItem
  }

  class ListDefinition {
    - name : String
    - items : HashMap<InkListItem, Integer>
    - itemNameToValues : HashMap<String, Integer>
    --
    + getName() : String
    + getItems() : HashMap<InkListItem, Integer>
    + getValueForItem(InkListItem) : Integer
    + containsItem(InkListItem) : boolean
    + containsItemWithName(String) : boolean
    + getItemWithValue(int) : InkListItem
  }

  class ListDefinitionsOrigin {
    - lists : HashMap<String, ListDefinition>
    - allUnambiguousListValueCache : HashMap<String, ListValue>
    --
    + getListDefinition(String) : ListDefinition
    + getLists() : List<ListDefinition>
    ~ findSingleItemListWithName(String) : ListValue
  }
}


' =========================================================================
' 5. STATE
' =========================================================================
package "State" <<Rectangle>> {

  class StoryState {
    - currentErrors : List<String>
    - currentWarnings : List<String>
    - currentTurnIndex : int
    - didSafeExit : boolean
    - divertedPointer : Pointer
    - evaluationStack : List<RTObject>
    - story : Story
    - storySeed : int
    - previousRandom : int
    - turnIndices : HashMap<String, Integer>
    - variablesState : VariablesState
    - visitCounts : HashMap<String, Integer>
    - currentText : String
    - currentTags : List<String>
    - patch : StatePatch
    - namedFlows : HashMap<String, Flow>
    - currentFlow : Flow
    --
    + {static} kInkSaveStateVersion : int = 10
    + {static} kMinCompatibleLoadVersion : int = 8
    + {static} kDefaultFlowName : String
    --
    + toJson() : String
    + toJson(OutputStream) : void
    + loadJson(String) : void
    + getCurrentPathString() : String
    + previousPathString() : String
    + getCurrentFlowName() : String
    + currentFlowIsDefaultFlow() : boolean
    + aliveFlowNames() : List<String>
    + getOutputStream() : List<RTObject>
    + visitCountAtPathString(String) : int
    + forceEnd() : void
    ~ addError(String, boolean) : void
    ~ copyAndStartPatching(boolean) : StoryState
  }

  class CallStack {
    - threadCounter : int
    - startOfRoot : Pointer
    - threads : List<Thread>
    --
    + canPop() : boolean
    + canPop(PushPopType) : boolean
    + canPopThread() : boolean
    + getDepth() : int
    + getCurrentElement() : Element
    + getCurrentElementIndex() : int
    + getElements() : List<Element>
    + getcurrentThread() : Thread
    + push(PushPopType) : void
    + push(PushPopType, int, int) : void
    + pop() : void
    + pop(PushPopType) : void
    + pushThread() : void
    + popThread() : void
    + forkThread() : Thread
    + contextForVariableNamed(String) : int
    + getTemporaryVariableWithName(String, int) : RTObject
    + setTemporaryVariable(String, RTObject, boolean, int) : void
    + getThreadWithIndex(int) : Thread
    + writeJson(SimpleJson.Writer) : void
    + setJsonToken(HashMap, Story) : void
    ~ getCallStackTrace() : String
  }

  class "CallStack.Element" as CSElement {
    + currentPointer : Pointer
    + inExpressionEvaluation : boolean
    + temporaryVariables : HashMap<String, RTObject>
    + type : PushPopType
    + evaluationStackHeightWhenPushed : int
    + functionStartInOuputStream : int
    --
    + copy() : Element
  }

  class "CallStack.Thread" as CSThread {
    + callstack : List<Element>
    + previousPointer : Pointer
    + threadIndex : int
    --
    + copy() : Thread
    + writeJson(SimpleJson.Writer) : void
  }

  class Flow {
    + name : String
    + callStack : CallStack
    + outputStream : List<RTObject>
    + currentChoices : List<Choice>
    --
    + writeJson(SimpleJson.Writer) : void
    + loadFlowChoiceThreads(HashMap, Story) : void
  }

  note bottom of Flow
    **→ ink.kt** : InkFlow implements **Flow<InkObject>**
    Java Flow is a data holder; Kotlin adds reactive stream.
    Java VariableObserver/ErrorHandler callbacks →
    Kotlin **Flow collectors** on MutableSharedFlow.
    Java Thread → Kotlin **InkThread** (coroutine model).
    Multi-tenant: each session gets own InkFlow stream.
  end note

  class StatePatch {
    - globals : HashMap<String, RTObject>
    - changedVariables : HashSet<String>
    - visitCounts : HashMap<Container, Integer>
    - turnIndices : HashMap<Container, Integer>
    --
    + getGlobal(String) : RTObject
    + setGlobal(String, RTObject) : void
    + addChangedVariable(String) : void
    + getVisitCount(Container) : Integer
    + setVisitCount(Container, int) : void
    + getTurnIndex(Container) : Integer
    + setTurnIndex(Container, int) : void
    + getGlobals() : HashMap<String, RTObject>
    + getChangedVariables() : HashSet<String>
    + getVisitCounts() : HashMap<Container, Integer>
    + getTurnIndices() : HashMap<Container, Integer>
  }

  class VariablesState << Iterable<String> >> {
    - batchObservingVariableChanges : boolean
    - callStack : CallStack
    - changedVariablesForBatchObs : HashSet<String>
    - globalVariables : HashMap<String, RTObject>
    - defaultGlobalVariables : HashMap<String, RTObject>
    - variableChangedEvent : VariableChanged
    - listDefsOrigin : ListDefinitionsOrigin
    - patch : StatePatch
    --
    + assign(VariableAssignment, RTObject) : void
    + get(String) : Object
    + set(String, Object) : void
    + getVariableWithName(String) : RTObject
    + getVariableChangedEvent() : VariableChanged
    + setVariableChangedEvent(VariableChanged) : void
    + startVariableObservation() : void
    + completeVariableObservation() : HashMap<String, RTObject>
    + notifyObservers(HashMap<String, RTObject>) : void
    + iterator() : Iterator<String>
    ~ applyPatch() : void
    ~ writeJson(SimpleJson.Writer) : void
    ~ setJsonToken(HashMap) : void
    ~ snapshotDefaultGlobals() : void
    + {static} dontSaveDefaultValues : boolean
  }

  interface "VariablesState.VariableChanged" as VariableChanged {
    + variableStateDidChangeEvent(String, RTObject) : void
  }
}


' =========================================================================
' 6. RUNTIME
' =========================================================================
package "Runtime" <<Rectangle>> {

  class Story << VariablesState.VariableChanged >> {
    - mainContentContainer : Container
    - listDefinitions : ListDefinitionsOrigin
    - allowExternalFunctionFallbacks : boolean
    - externals : HashMap<String, ExternalFunctionDef>
    - hasValidatedExternals : boolean
    - state : StoryState
    - temporaryEvaluationContainer : Container
    - variableObservers : HashMap<String, List<VariableObserver>>
    --
    + {static} inkVersionCurrent : int = 21
    + {static} inkVersionMinimumCompatible : int = 18
    --
    + Continue() : String
    + continueAsync(float) : void
    + asyncContinueComplete() : boolean
    + continueMaximally() : String
    + canContinue() : boolean
    + getCurrentText() : String
    + getCurrentTags() : List<String>
    + getCurrentChoices() : List<Choice>
    + getCurrentErrors() : List<String>
    + getCurrentWarnings() : List<String>
    + hasError() : boolean
    + hasWarning() : boolean
    + getState() : StoryState
    + getVariablesState() : VariablesState
    + getListDefinitions() : ListDefinitionsOrigin
    + getMainContentContainer() : Container
    + chooseChoiceIndex(int) : void
    + choosePathString(String) : void
    + choosePathString(String, boolean, Object[]) : void
    + evaluateExpression(Container) : RTObject
    + getGlobalTags() : List<String>
    + tagsForContentAtPath(String) : List<String>
    + contentAtPath(Path) : SearchResult
    + bindExternalFunction(String, ExternalFunction<?>, boolean) : void
    + unbindExternalFunction(String) : void
    + observeVariable(String, VariableObserver) : void
    + observeVariables(List<String>, VariableObserver) : void
    + removeVariableObserver(VariableObserver, String) : void
    + startProfiling() : Profiler
    + endProfiling() : void
    + toJson() : String
    + toJson(OutputStream) : void
    + resetState() : void
    + resetCallstack() : void
    + buildStringOfHierarchy() : String
    + getCurrentFlowName() : String
    + currentFlowIsDefaultFlow() : boolean
    + aliveFlowNames() : List<String>
    + switchFlow(String) : void
    + removeFlow(String) : void
    + switchToDefaultFlow() : void
    + validateExternalBindings() : void
    + allowExternalFunctionFallbacks() : boolean
  }

  interface "Story.ExternalFunction<R>" as ExternalFunction {
    + call(Object...) : R
  }

  abstract class "Story.ExternalFunction0<R>" as ExternalFunction0 {
    # {abstract} call() : R
  }

  abstract class "Story.ExternalFunction1<T,R>" as ExternalFunction1 {
    # {abstract} call(T) : R
  }

  abstract class "Story.ExternalFunction2<T1,T2,R>" as ExternalFunction2 {
    # {abstract} call(T1, T2) : R
  }

  abstract class "Story.ExternalFunction3<T1,T2,T3,R>" as ExternalFunction3 {
    # {abstract} call(T1, T2, T3) : R
  }

  interface "Story.VariableObserver" as VariableObserver {
    + call(String, Object) : void
  }

  class Profiler {
    - continueWatch : Stopwatch
    - stepWatch : Stopwatch
    - snapWatch : Stopwatch
    - continueTotal : double
    - snapTotal : double
    - stepTotal : double
    - currStepStack : String[]
    - rootNode : ProfileNode
    - numContinues : int
    --
    + getRootNode() : ProfileNode
    + report() : String
    + stepLengthReport() : String
    + megalog() : String
    ~ preContinue() : void
    ~ postContinue() : void
    ~ preStep() : void
    ~ step(CallStack) : void
    ~ postStep() : void
    ~ preSnapshot() : void
    ~ postSnapshot() : void
    + {static} formatMillisecs(double) : String
  }

  class ProfileNode {
    - nodes : HashMap<String, ProfileNode>
    - selfMillisecs : double
    - totalMillisecs : double
    - selfSampleCount : int
    - totalSampleCount : int
    - key : String
    + openInUI : boolean
    --
    + hasChildren() : boolean
    + getKey() : String
    + getTotalMillisecs() : int
    + getOwnReport() : String
    + getDescendingOrderedNodes() : Iterable<Entry<String, ProfileNode>>
    ~ addSample(String[], double) : void
    ~ addSample(String[], int, double) : void
  }
}


' =========================================================================
' 7. SERIALIZATION
' =========================================================================
package "Serialization" <<Rectangle>> {

  class SimpleJson {
    + {static} textToDictionary(String) : HashMap<String, Object>
    + {static} textToArray(String) : List<Object>
  }

  class "SimpleJson.Reader" as SJReader {
    - offset : int
    - rootObject : Object
    - text : String
    --
    ~ toHashMap() : HashMap<String, Object>
    ~ toArray() : List<Object>
    ~ readObject() : Object
    ~ readHashMap() : HashMap<String, Object>
    ~ readArray() : List<Object>
    ~ readString() : String
    ~ readNumber() : Object
  }

  class "SimpleJson.Writer" as SJWriter {
    --
    + writeObjectStart() : void
    + writeObjectEnd() : void
    + writeArrayStart() : void
    + writeArrayEnd() : void
    + writePropertyStart(String) : void
    + writePropertyStart(int) : void
    + writePropertyEnd() : void
    + writeProperty(String, InnerWriter) : void
    + writeProperty(String, String) : void
    + writeProperty(String, int) : void
    + writeProperty(String, boolean) : void
    + write(int) : void
    + write(float) : void
    + write(String) : void
    + write(boolean) : void
    + writeNull() : void
    + writeObject(InnerWriter) : void
  }

  interface "SimpleJson.InnerWriter" as InnerWriter {
    + write(Writer) : void
  }

  class Json {
    + {static} jArrayToRuntimeObjList(List<Object>) : List<RTObject>
    + {static} jArrayToRuntimeObjList(List<Object>, boolean) : List<RTObject>
    + {static} jTokenToRuntimeObject(Object) : RTObject
    + {static} writeDictionaryRuntimeObjs(Writer, HashMap) : void
    + {static} writeListRuntimeObjs(Writer, List<RTObject>) : void
    + {static} writeIntDictionary(Writer, HashMap) : void
    + {static} writeRuntimeObject(Writer, RTObject) : void
    + {static} writeRuntimeContainer(Writer, Container) : void
    + {static} writeChoice(Writer, Choice) : void
    + {static} jObjectToHashMapRuntimeObjs(HashMap) : HashMap<String, RTObject>
  }
}


' =========================================================================
' 8. INFRASTRUCTURE
' =========================================================================
package "Infrastructure" <<Rectangle>> {

  class Stopwatch {
    - startTime : long
    - stopTime : long
    - running : boolean
    --
    + start() : void
    + stop() : void
    + reset() : void
    + getElapsedTicks() : long
    + getElapsedMilliseconds() : long
    + getElapsedSeconds() : long
    + getElapsedMinutes() : long
    + getElapsedHours() : long
    + getElapsed() : String
  }

  class StoryException << Exception >> {
    + useEndLineNumber : boolean
  }

  class Error {
  }

  interface "Error.ErrorHandler" as ErrorHandler {
    + error(String, ErrorType) : void
  }

  enum "Error.ErrorType" as ErrorType {
    Author
    Warning
    Error
  }

  enum PushPopType {
    Tunnel
    Function
    FunctionEvaluationFromGame
  }

  interface INamedContent {
    + getName() : String
    + hasValidName() : boolean
  }

  class StringExt {
    + {static} join(String, List<T>) : String
  }
}


' =========================================================================
' INHERITANCE RELATIONSHIPS
' =========================================================================

' -- Core hierarchy --
Container -up-|> RTObject
Container .up.|> INamedContent

' -- Content extends RTObject --
ChoicePoint -up-|> RTObject
Choice -up-|> RTObject
Divert -up-|> RTObject
Glue -up-|> RTObject
Tag -up-|> RTObject
Void -up-|> RTObject
ControlCommand -up-|> RTObject
VariableAssignment -up-|> RTObject
VariableReference -up-|> RTObject
NativeFunctionCall -up-|> RTObject

' -- Value hierarchy --
AbstractValue -up-|> RTObject
Value_T -up-|> AbstractValue
BoolValue -up-|> Value_T : T=Boolean
IntValue -up-|> Value_T : T=Integer
FloatValue -up-|> Value_T : T=Float
StringValue -up-|> Value_T : T=String
DivertTargetValue -up-|> Value_T : T=Path
VariablePointerValue -up-|> Value_T : T=String
ListValue -up-|> Value_T : T=InkList

' -- Story implements VariableChanged --
Story ..|> VariableChanged

' -- ExternalFunction hierarchy --
ExternalFunction0 ..|> ExternalFunction
ExternalFunction1 ..|> ExternalFunction
ExternalFunction2 ..|> ExternalFunction
ExternalFunction3 ..|> ExternalFunction

' -- ControlCommand inner enum --
ControlCommand +-- CommandType

' -- CallStack inner classes --
CallStack +-- CSElement
CallStack +-- CSThread

' -- SimpleJson inner classes --
SimpleJson +-- SJReader
SimpleJson +-- SJWriter
SimpleJson +-- InnerWriter

' -- Error inner classes --
Error +-- ErrorHandler
Error +-- ErrorType

' -- VariablesState inner interface --
VariablesState +-- VariableChanged

' -- Story inner classes --
Story +-- ExternalFunction
Story +-- ExternalFunction0
Story +-- ExternalFunction1
Story +-- ExternalFunction2
Story +-- ExternalFunction3
Story +-- VariableObserver

' -- Path inner class --
Path +-- PathComponent


' =========================================================================
' KEY ASSOCIATIONS
' =========================================================================

' -- Core associations --
RTObject "0..1" o--> "parent" Container
RTObject --> DebugMetadata : debugMetadata
RTObject --> Path : path
Container "1" *--> "*" RTObject : content
Container "1" *--> "*" INamedContent : namedContent
Pointer --> Container : container
SearchResult --> RTObject : obj

' -- Story main associations --
Story "1" *--> "1" StoryState : state
Story "1" *--> "1" Container : mainContentContainer
Story "1" *--> "1" ListDefinitionsOrigin : listDefinitions
Story "1" *--> "*" ExternalFunction : externals
Story "1" *--> "*" VariableObserver : variableObservers

' -- StoryState associations --
StoryState "1" *--> "1" VariablesState : variablesState
StoryState "1" o--> "1" Story : story
StoryState "1" *--> "*" RTObject : evaluationStack
StoryState "1" *--> "1" Flow : currentFlow
StoryState "1" *--> "*" Flow : namedFlows
StoryState "1" o--> "0..1" StatePatch : patch

' -- Flow associations --
Flow "1" *--> "1" CallStack : callStack
Flow "1" *--> "*" RTObject : outputStream
Flow "1" *--> "*" Choice : currentChoices

' -- CallStack associations --
CallStack "1" *--> "*" CSThread : threads
CSThread "1" *--> "*" CSElement : callstack
CSElement --> Pointer : currentPointer
CSElement --> PushPopType : type

' -- VariablesState associations --
VariablesState --> CallStack : callStack
VariablesState --> ListDefinitionsOrigin : listDefsOrigin
VariablesState --> StatePatch : patch

' -- Divert associations --
Divert --> Path : targetPath
Divert --> Pointer : targetPointer
Divert --> PushPopType : stackPushType

' -- Choice associations --
Choice --> Path : targetPath
Choice --> CSThread : threadAtGeneration

' -- ChoicePoint associations --
ChoicePoint --> Path : pathOnChoice

' -- VariableReference associations --
VariableReference --> Path : pathForCount

' -- Value type associations --
NativeFunctionCall ..> ValueType : operationFuncs key
NativeFunctionCall ..> AbstractValue : creates via create()
ListValue --> InkList : value

' -- List associations --
InkList "1" o--> "*" ListDefinition : origins
InkList "1" *--> "*" InkListItem : keys
ListDefinition "1" *--> "*" InkListItem : items
ListDefinitionsOrigin "1" *--> "*" ListDefinition : lists
ListDefinitionsOrigin ..> ListValue : cache

' -- Profiler associations --
Profiler "1" *--> "1" ProfileNode : rootNode
Profiler "1" *--> "3" Stopwatch : watches
ProfileNode "1" *--> "*" ProfileNode : nodes (children)

' -- Serialization usage --
Json ..> RTObject : serializes
Json ..> SJWriter : uses
StoryState ..> SJWriter : writeJson
CallStack ..> SJWriter : writeJson
Flow ..> SJWriter : writeJson
VariablesState ..> SJWriter : writeJson

note as N_GAPS
  **Java (blade-ink) → ink.kt Gap Analysis (2026-03-01)**
  ═════════════════════════════════════════════════════════

  **Porting complete: 46 Java files → 36 Kotlin files.**
  Consolidation: 8 value files → 1 sealed Value.kt,
  ProfileNode → combined into Profiler.kt,
  StringExt → removed (Kotlin stdlib).

  **Java → Kotlin idiomatic changes**

  | Java | Kotlin | Benefit |
  | HashMap | LinkedHashMap | Insertion-order preserved |
  | getter/setter | property syntax | Concise |
  | ExternalFunction0/1/2/3 | fun interface | Single SAM lambda |
  | VariableChanged interface | fun interface | Lambda-friendly |
  | ErrorHandler interface | fun interface | Lambda-friendly |
  | InnerWriter interface | fun interface | Lambda-friendly |
  | Stopwatch (System.nanoTime) | TimeSource.Monotonic | Cross-platform |
  | RTObject base class | InkObject | No java.lang clash |
  | AbstractValue + Value<T> | sealed Value<T> | Exhaustive when() |
  | null checks + casts | smart casts + ?.let | Null-safe |
  | StringBuilder loops | buildString {} | Idiomatic |
  | Locale.getDefault() | Kotlin toString() | Locale-free |

  **Java bugs fixed in ink.kt**

  | Bug | Location | Fix |
  | setTemporaryVariable infinite recursion | CallStack | Default params |
  | HashMap iteration order non-deterministic | Throughout | LinkedHashMap |
  | Locale-dependent float formatting | NativeFunctionCall | Kotlin toString |

  **Java-only files removed (no Kotlin equivalent)**

  | Java File | Reason |
  | StringExt.java | Kotlin stdlib String extensions |
  | Error.java | ErrorType + ErrorHandler split to top-level |
  | 8 separate value files | Consolidated to sealed Value.kt |

  **Java features NOT ported (ink.kt adds beyond Java)**

  | Feature | ink.kt | Java | Source |
  | onDidContinue callback | ✅ | ⬜ | inkjs |
  | onMakeChoice callback | ✅ | ⬜ | inkjs |
  | onEvaluateFunction callback | ✅ | ⬜ | inkjs |
  | onCompleteEvaluateFunction | ✅ | ⬜ | inkjs |
  | onChoosePathString callback | ✅ | ⬜ | inkjs |
  | ContinueSingleStep() public | ✅ | ⬜ pkg-private | inkjs |
  | InkClock (pluggable) | ✅ | ⬜ | ink.kt unique |
  | InkRuntime interface | ✅ | ⬜ | ink.kt unique |

  **mica → ink.kt merge status (2026-02-28)**

  | Step | Status |
  | mica fully KMP-ported (6 JVM deps replaced) | ✅ Done |
  | BigDecimal → Double | ✅ Done |
  | Jackson → kotlinx.serialization | ✅ Done |
  | Parser fields merged into ink.kt classes | ✅ Done |
  | InkObject (+id/text/lineNumber/count from mica Content) | ✅ Done |
  | Container (+index/children/add/get) | ✅ Done |
  | Choice (+level/conditions/repeatable) | ✅ Done |
  | Story (+parserMode fields) | ✅ Done |
  | Move 22 non-colliding mica classes to ink.kt | ⬜ Next |
  | Delete mica/ directory | ⬜ Next |

  **Porting status: ✅ COMPLETE (blade-ink → ink.kt)**
  All 46 Java source files accounted for.
  36 Kotlin files in ink.kt package.
  ink-proof: 7 bytecode + 135 ink conformance tests.
  Parser fields from mica now merged into ink.kt data classes.
end note

note as N_INKKT
  **ink.[lang].puml Cross-Reference (2026-03-01)**
  ════════════════════════════════════════════════
  See **ink.kt.puml** for complete
  56-class diagram with method-level
  cross-language line references.

  **All 7 ink.[lang].puml diagrams:**
  | Diagram | Language | Focus |
  | ink.kt.puml | Kotlin | Runtime (56 classes) |
  | ink.proto.puml | proto3 | Messages (16 files) |
  | ink.java.puml | Java | blade-ink + mica (this file) |
  | ink.cs.puml | C# | inkle reference |
  | ink.js.puml | JS/TS | inkjs + ink/js |
  | **ink.ts.puml** | **TS** | **Proto model (NEW)** |
  | **ink.py.puml** | **PY** | **Proto model (NEW)** |
end note

N_GAPS .. Story
N_INKKT .. VariablesState

newpage

' ==============================================================================
' ink.kt.mica — Parser-Based Ink Runtime Reference Implementation
' Package: ink.kt.mica
' Source:  ink-kmp-mcp/src/commonMain/kotlin/ink/kt/mica/
'
' Ported from mica-ink (Java) → idiomatic Kotlin.
' Parses .ink files at runtime (no compiler needed).
' Reference for building ink.kt parser capabilities.
'
' Previously in ink.kt.mica.puml — merged here since mica is JVM-only (from Java).
'
' Last updated: 2026-03-01
' ==============================================================================

skinparam backgroundColor #FAFAFA
skinparam shadowing false
skinparam roundcorner 8

skinparam class {
    BackgroundColor #FFF3E0
    BorderColor #E65100
    HeaderBackgroundColor #F57C00
    FontColor #212121
    FontName JetBrains Mono
    FontSize 11
    HeaderFontColor #FFFFFF
    HeaderFontSize 12
    AttributeFontSize 10
    StereotypeFontSize 9
}

skinparam interface {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
    HeaderBackgroundColor #388E3C
    FontColor #212121
    HeaderFontColor #FFFFFF
    FontSize 11
}

skinparam object {
    BackgroundColor #F3E5F5
    BorderColor #6A1B9A
    HeaderBackgroundColor #7B1FA2
    FontColor #212121
    HeaderFontColor #FFFFFF
    FontSize 11
}

skinparam note {
    BackgroundColor #FFFDE7
    BorderColor #F9A825
    FontSize 10
    FontName JetBrains Mono
}

title ink.kt.mica — Parser-Based Ink Runtime\n(Reference for ink.kt KMP port — merged from ink.kt.mica.puml)
footer ink.kt.mica | ported from mica-ink (Java) | parses .ink at runtime | 28 files ~2100 LOC

' ═══════════════════════════════════════════════════════════
' CORE HIERARCHY
' ═══════════════════════════════════════════════════════════

package "Core" #FFF3E0 {

    class Content <<open>> {
        + id : String
        + text : String
        + parent : Container?
        + lineNumber : Int
        ~ count : Int
        --
        + getText(story: Story) : String
        .. companion ..
        {static} getId(parent: Container) : String
    }

    class Container <<open>> {
        ~ index : Int
        ~ children : MutableList<Content>
        --
        + add(item: Content)
        + get(i: Int) : Content
        + indexOf(c: Content) : Int
        + size : Int <<get>>
    }

    class ParameterizedContainer <<open>> {
        + parameters : List<String>
        ~ values : MutableMap<String, Any>
        --
        + hasValue(key: String) : Boolean
        + getValue(key: String) : Any
        + setValue(key: String, value: Any)
        .. companion ..
        {static} getParameters(header: String) : List<String>
    }

    Content <|-- Container
    Container <|-- ParameterizedContainer
}

' ═══════════════════════════════════════════════════════════
' AST NODES (parser-specific — not in ink.kt)
' ═══════════════════════════════════════════════════════════

package "AST Nodes" #FFECB3 {

    class Knot {
        ~ isFunction : Boolean
        --
        + eval(params, vMap) : Any
        .. companion ..
        {static} isKnot(str) : Boolean
        {static} getId(id) : String
        {static} isFunction(id) : Boolean
    }

    class Stitch {
        .. companion ..
        {static} isStitchHeader(str) : Boolean
        {static} getId(header, parent) : String
        {static} getParent(container) : Container
    }

    class Choice {
        + level : Int
        - conditions : MutableList<String>
        - repeatable : Boolean
        --
        + isFallBack() : Boolean
        + evaluateConditions(story) : Boolean
        .. companion ..
        {static} getChoiceDepth(line) : Int
        {static} getId(header, parent) : String
        {static} extractChoiceText(header) : String
        {static} getParent(container, lvl) : Container
    }

    class Gather {
        + level : Int
        .. companion ..
        {static} getChoiceDepth(line) : Int
        {static} getId(text, parent) : String
        {static} getParent(container, lvl) : Container
    }

    class Conditional {
        - seqType : SequenceType
        --
        + resolveConditional(story) : Container
        .. companion ..
        {static} isConditionalHeader(str) : Boolean
    }

    class ConditionalOption {
        + evaluate(vMap) : Boolean
        .. companion ..
        {static} getCondition(txt) : String
    }

    class Declaration {
        - isDeclaration : Boolean
        --
        + evaluate(story: Story)
        .. companion ..
        {static} evaluate(str, variables) : Any
        {static} isVariableHeader(str) : Boolean
    }

    class Divert {
        + resolveDivert(story) : Container
    }

    class Tag {
    }

    ParameterizedContainer <|-- Knot
    ParameterizedContainer <|-- Stitch
    Container <|-- Choice
    Container <|-- Gather
    Container <|-- Conditional
    Container <|-- ConditionalOption
    Content <|-- Declaration
    Content <|-- Divert
    Content <|-- Tag
}

' ═══════════════════════════════════════════════════════════
' EXPRESSION EVALUATOR
' ═══════════════════════════════════════════════════════════

package "Expression" #E1F5FE {

    class Expression {
        - mc : MathContext
        - rpn : List<String>?
        - operators : SortedMap<String, Operator>
        - expression : String
        --
        + eval(vMap: VariableMap) : Any
        + setPrecision(precision: Int) : Expression
        + setRoundingMode(mode) : Expression
        .. companion ..
        {static} PI : BigDecimal
        {static} e : BigDecimal
        {static} isNumber(st: String) : Boolean
    }

    abstract class Operator {
        + oper : String
        + precedence : Int
        + isLeftAssoc : Boolean
        --
        {abstract} + eval(v1: Any, v2: Any) : Any
    }

    Expression --> "*" Operator : operators
}

' ═══════════════════════════════════════════════════════════
' RUNTIME
' ═══════════════════════════════════════════════════════════

package "Runtime" #E8F5E9 {

    class Story <<VariableMap>> {
        ~ wrapper : StoryWrapper
        ~ container : Container
        ~ content : MutableMap<String, Content>
        ~ fileNames : MutableList<String>
        ~ variables : MutableMap<String, Any>
        ~ text : MutableList<String>
        ~ choices : MutableList<Container>
        - functions : SortedMap<String, Function>
        - interrupts : MutableList<StoryInterrupt>
        --
        + next() : List<String>
        + choose(idx: Int)
        + choiceSize : Int <<get>>
        + choiceText(i: Int) : String
        + putVariable(key, value)
        + putVariables(map)
        + isEnded : Boolean <<get>>
        + setContainer(s: String)
        + resolveInterrupt(divert) : String
        + getDivert(d) : Container
        + add(story: Story)
        + clear()
        + contains(s: String) : Boolean
        .. VariableMap impl ..
        + logException(e)
        + hasValue(token) : Boolean
        + getValue(token) : Any
        + hasFunction(token) : Boolean
        + getFunction(token) : Function
        + hasGameObject(token) : Boolean
        + debugInfo() : String
    }

    interface VariableMap {
        + logException(e: Exception)
        + hasValue(token: String) : Boolean
        + getValue(token: String) : Any
        + hasFunction(token: String) : Boolean
        + getFunction(token: String) : Function
        + hasGameObject(token: String) : Boolean
        + debugInfo() : String
    }

    interface Function {
        + numParams : Int
        + isFixedNumParams : Boolean
        + eval(params, vMap) : Any
    }

    Story ..|> VariableMap
    Knot ..|> Function
}

' ═══════════════════════════════════════════════════════════
' PARSER + SERIALIZATION
' ═══════════════════════════════════════════════════════════

package "Parser" #F3E5F5 {

    object InkParser {
        + parse(provider, fileName) : Story
        + parse(inputStream, provider, fileName) : Story
        ~ parseDivert(lineNumber, line, container) : List<Content>
    }

    interface StoryWrapper {
        + getStream(fileId) : InputStream
        + getStoryObject(objId) : Any
        + getInterrupt(s) : StoryInterrupt
        + resolveTag(t: String)
        + logDebug(m: String)
        + logError(m: String)
        + logException(e: Exception)
    }

    abstract class StoryInterrupt {
        + id : String
        + text : String
        + condition : String
        + file : String
        + isChoice : Boolean
        + isDivert : Boolean
        + isActive : Boolean
    }

    object StoryLoader {
        + loadStream(p: JsonParser, story: Story)
    }

    object StorySaver {
        + saveStream(g: JsonGenerator, story: Story)
    }

    object StoryText {
        + getText(text, count, variables) : String
    }

    object Symbol {
        + CBRACE_LEFT/RIGHT : Char
        ~ DIVERT, GLUE, DOT : String
        ~ CHOICE_DOT/PLUS, DASH : Char
        ~ HEADER, COMMENT : Char/String
        .. (30+ constants) ..
    }

    object StoryJson {
        + FILE, FILES, CONTENT : String
        + COUNT, VARIABLES : String
        + CONTAINER, TEXT, CHOICES : String
        .. (14 constants) ..
    }
}

' ═══════════════════════════════════════════════════════════
' EXCEPTIONS
' ═══════════════════════════════════════════════════════════

package "Exceptions" #FFEBEE {
    class InkRunTimeException
    class InkParseException
    class InkLoadingException
}

' ═══════════════════════════════════════════════════════════
' RELATIONSHIPS
' ═══════════════════════════════════════════════════════════

InkParser --> Story : creates
InkParser --> StoryWrapper : uses
Story --> StoryWrapper : wrapper
Story --> "*" StoryInterrupt : interrupts
Story --> StoryText : text evaluation
StoryLoader --> Story : loads state into
StorySaver --> Story : saves state from
Expression --> VariableMap : evaluates against

' ═══════════════════════════════════════════════════════════
' COMPARISON NOTES
' ═══════════════════════════════════════════════════════════

note as N_MICA_1
  **ink.kt.mica vs ink.kt Architecture Comparison (2026-02-28)**
  ══════════════════════════════════════════════════════════════

  **mica** (parser-based) — ✅ fully KMP-ported:
  - Parses .ink source files at runtime
  - Tree traversal with container.index pointer
  - Double values (was BigDecimal → ✅ KMP-ported)
  - Expression evaluator (kotlinx.serialization → ✅ KMP-ported)
  - 28 classes, ~2100 LOC, zero JVM dependencies

  **ink.kt** (compiled runtime) — ✅ parser fields merged:
  - Loads pre-compiled JSON bytecode
  - CallStack + evaluation stack (VM-style)
  - Sealed Value hierarchy (Bool/Int/Float/String/List)
  - NativeFunctionCall operator dispatch
  - 36 classes, ~8000+ LOC
  - +mica fields on InkObject, Container, Choice, Story

  **Unique to mica (ready to move to ink.kt)**:
  ✅ InkParser — parse .ink at runtime (KMP-ready)
  ✅ Expression — standalone expression evaluator (KMP-ready)
  ✅ Symbol — ink syntax constants (KMP-ready)
  ✅ StoryInterrupt — conditional flow override (KMP-ready)

  **Unique to ink.kt (mature runtime)**:
  ✅ CallStack + Thread — proper scope management
  ✅ Path + Pointer — structured navigation
  ✅ Flow — named execution contexts
  ✅ Profiler — instruction-level profiling
  ✅ SimpleJson — zero-dep JSON parser

  **Three-layer target (code-first)**:
  ink.model → ink.kt → ink.kt.services
  KT/KMP compiler → native + JVM + JS
  C# + Java compilers unchanged (test oracles, same JSON)
end note

note as N_MICA_2
  **ink-proof conformance (2026)**
  ══════════════════════════════
  Test resources:
  - 7 bytecode tests (B001-B007)
  - 135 ink tests (I001-I135)

  ink.kt can run bytecode tests directly.
  mica can run ink tests directly (with StoryWrapper).
  Both implement InkRuntime interface.
end note

note as N_MICA_3
  **mica → ink.kt Merge Status (2026-03-01)**
  ═════════════════════════════════════════════

  **Phase 1: ✅ COMPLETE — KMP port + parser fields**

  | Step | What | Status |
  | KMP port | All 6 JVM deps removed | ✅ Done |
  | InkObject | +id, +text, +lineNumber, +count from Content | ✅ Merged |
  | Container | +index, +children, +add/get/indexOf/size | ✅ Merged |
  | Choice | +level, +conditions, +repeatable | ✅ Merged |
  | Story | +parserMode fields (wrapper, container, etc.) | ✅ Merged |
  | Tag | text override compatible | ✅ Compatible |

  **Phase 2: NEXT — Move 22 non-colliding classes**

  | mica Class | ink.kt Equivalent | Move Status |
  | InkParser | — | ⬜ Move to ink.kt |
  | Expression | — | ⬜ Move to ink.kt |
  | Symbol | — | ⬜ Move to ink.kt |
  | StoryInterrupt | — | ⬜ Move to ink.kt |
  | StoryText | — | ⬜ Move to ink.kt |
  | StoryWrapper | — | ⬜ Move to ink.kt |
  | Operator | NativeFunctionCall | ✅ Different approach |
  | VariableMap | VariablesState | ✅ Different approach |
  | Function | ExternalFunction | ✅ fun interface |
  | StorySaver | JsonSerialisation | ✅ Different format |
  | StoryLoader | JsonSerialisation | ✅ Different format |
  | StoryJson | JsonSerialisation | ✅ Constants merged |

  **Phase 3: FUTURE — KT/KMP compiler**
  Port compiler from C#/Java/JS → KT/KMP
  All 3 compilers (C#, Java, KT) → same JSON output
  C# + Java unchanged (test oracles)
end note

N_MICA_1 .. Story
N_MICA_2 .. InkParser
N_MICA_3 .. Expression

legend bottom right
  |= Color |= Meaning |
  | <#FFF3E0> | mica class (parser-based) |
  | <#E8F5E9> | Interface |
  | <#F3E5F5> | Object singleton |
  | <#FFECB3> | AST node (parser-specific) |
  | <#E1F5FE> | Expression evaluator |
  | <#FFEBEE> | Exception classes |
  |= Status |= Meaning |
  | ✅ | Complete / portable to ink.kt |
  | ⬜ | Pending / needs work |
endlegend

@enduml
